Kocos = {}

_KVERSION = "KOCOS v0.-1.0"
_OSVERSION = _OSVERSION or "Unnamed KOCOS"

local argv = {...}

---@alias Kocos.device {address: string, type: string, slot: integer}|table

---@class Kocos.config
---@field debugger? string
---@field root? string
---@field ramfs? Kocos.ramfs
---@field noOcelotLog? boolean
---@field minLog? integer
---@field pollInterval? number
--- For when <50% battery
---@field midBatteryPollInterval? number
--- For when <10% battery
---@field lowBatteryPollInterval? number
---@field minEventPoll? number
---@field useExtremelySecurePidGeneration? boolean
---@field packagePath? string
---@field packageCPath? string
---@field luaExecRT? string
---@field luaExecRTF? string
---@field hostname? string
---@field termStdColors? table<integer, integer>
---@field termDefaultFg? integer
---@field termDefaultBg? integer

Kocos.biosBootTime = computer.uptime()

---@type Kocos.config
Kocos.args = {}

if argv[1] == "kocos" then
	-- KOCOS boot protocol
	Kocos.args = argv[2]
elseif not argv[1] then
	-- generic boot protocol
else
	error("Unknown boot protocol! This is catastrophic")
end

Kocos.disableScreen = false
Kocos.disableScreenLogging = false
Kocos.disableDefaultPanicHandler = false
Kocos.hostname = Kocos.args.hostname or "localhost"

Kocos.args.minLog = Kocos.args.minLog or 1

function Kocos.poweroff(reboot)
	Kocos.event.notifyListeners("poweroff", reboot)
	computer.shutdown(reboot)
end

package = {}
package.preload = {}
package.loaded = {}
package.path = Kocos.args.packagePath or "/lib/?.lua;/lib/?/init.lua;?.lua;?/init.lua;/usr/lib/?.lua;/usr/lib/?/init.lua;/usr/local/lib/?.lua;/usr/local/lib/?/init.lua"
package.cpath = Kocos.args.packageCPath or "lib?.so;/lib/lib?.so;/usr/lib/lib?.so;/usr/local/lib/lib?.so"
package.config = "/\n;\n?\n!\n-"
---@generic T
---@param t T
---@return T
function table.copy(t)
	if type(t) == "table" then
		local nt = {}
		for k, v in pairs(t) do
			nt[k] = v
		end
		return nt
	else
		return t
	end
end

local luaglobals = {
	"_VERSION",
	"_OSVERSION",
	"_KVERSION",
	"assert",
	"error",
	"getmetatable",
	"ipairs",
	"next",
	"pairs",
	"pcall",
	"rawequal",
	"rawget",
	"rawset",
	"rawlen",
	"select",
	"setmetatable",
	"tonumber",
	"tostring",
	"type",
	"xpcall",
	"bit32",
	"table",
	"string",
	"math",
	"debug",
	"os",
	"checkArg",
	"unicode",
	"utf8",
	"coroutine",
	"load",
	"syscall",
	"require",
	"package",
	"writefile",
	"readfile",
	"loadfile",
	"dofile",
}

---@param src? _G
---@return _G
function table.luaglobals(src)
	src = src or _G
	local namespace = {}

	namespace._G = namespace

	for _, k in ipairs(luaglobals) do
		namespace[k] = table.copy(src[k])
	end
	namespace.package.loaded = {} -- fixed SO MUCH BS

	return namespace
end

---@generic T
---@param t T[]
---@return T[]
--- Mutates.
function table.reverse(t)
	local mid = math.ceil(#t/2)
	for i=1,mid do
		local j = #t - i + 1
		local tmp = t[i]
		t[i] = t[j]
		t[j] = tmp
	end
	return t
end

local function isGoodKey(s)
	return string.contains(s, "^[_a-zA-Z][_a-zA-Z0-9]*$", true)
end

---@param s string
---@param c? string
local function color(s, c)
	if not c then return s end
	return c .. s .. "\x1b[0m"
end

---@type table<type, string>
table.colorTypeInfo = {
	["nil"] = "\x1b[34m",
	boolean = "\x1b[34m",
	number = "\x1b[92m",
	string = "\x1b[32m",
	table = "\x1b[90m",
	thread = "\x1b[35m",
	["function"] = "\x1b[35m",
	["userdata"] = "\x1b[35m",
	--- definitely a lua type trust me
	docs = "\x1b[33m",
}

---@param colorinfo? table<type, string>
function table.serialize(val, refs, colorinfo)
	refs = refs or {}
	colorinfo = colorinfo or {}
	if type(val) == "table" then
		if refs[val] then return color("...", colorinfo.table) end
		refs[val] = true
		if getmetatable(val) and getmetatable(val).__tostring then
			return color(tostring(val), colorinfo.docs)
		end
		local s = color("{", colorinfo.table)
		local list = {}
		local done = {}
		for i, item in ipairs(val) do
			done[i] = true
			table.insert(list, table.serialize(item, refs, colorinfo))
		end
		for k, v in pairs(val) do
			if not done[k] then
				done[k] = true
				local pair = ""
				if isGoodKey(k) then
					pair = k
				else
					pair = "[" .. table.serialize(k, refs, colorinfo) .. "]"
				end
				k = pair .. " = " .. table.serialize(v, refs, colorinfo)
				table.insert(list, k)
			end
		end
		s = s .. table.concat(list, ", ")
		s = s .. color("}", colorinfo.table)
		return s
	elseif type(val) == "string" then
		return color(string.format("%q", val), colorinfo.string)
	else
		return color(tostring(val), colorinfo[type(val)])
	end
end

---@param s string
function table.deserialize(s)
	return assert(load("return " .. s, nil, nil, {
		inf = 1/0,
		nan = -(0/0),
	}))()
end

---@generic T
---@param t T[]
---@param v T
---@return boolean, integer?
function table.contains(t, v)
	for i, x in ipairs(t) do
		if v == x then
			return true, i
		end
	end
	return false
end

---@param memory integer
---@param spacing? string
function string.memformat(memory, spacing)
	spacing = spacing or ""

	local units = {"B", "KiB", "MiB", "GiB", "TiB", "PiB"}
	local scale = 1024

	while #units > 1 and memory >= scale do
		memory = memory / scale
		table.remove(units, 1)
	end

	return string.format("%.2f%s%s", memory, spacing, units[1])
end

---@param s string
---@param sub string
---@param pattern? boolean
function string.contains(s, sub, pattern)
	return string.find(s, sub, nil, not pattern) ~= nil
end

---@param inputstr string
---@param sep string
---@return string[]
function string.split(inputstr, sep)
	if sep == nil then
		sep = "%s"
	end
	if sep == "" then
		sep = "."
	else
		sep = "[^" .. sep .. "]*"
	end
	local t = {}
	for str in string.gmatch(inputstr, "("..sep..")") do
		table.insert(t, str)
	end
	return t
end

---@param s string
---@param prefix string
function string.startswith(s, prefix)
    return s:sub(1, #prefix) == prefix
end

---@param s string
---@param suffix string
function string.endswith(s, suffix)
    return s:sub(-#suffix) == suffix
end

---@param s string
---@param l integer
---@param c? string
--- We assure you this will not break npm
function string.leftpad(s, l, c)
    if #s > l then return s end
    c = c or " "
    return string.rep(c, l - #s) .. s
end

---@param s string
---@param l integer
---@param c? string
function string.rightpad(s, l, c)
    if #s > l then return s end
    c = c or "\0"
    return s .. string.rep(c, l - #s)
end

---@param x number
---@param min number
---@param max number
function math.clamp(x, min, max)
    return math.min(max, math.max(x, min))
end

---@param x number
---@param min1 number
---@param max1 number
---@param min2 number
---@param max2 number
function math.map(x, min1, max1, min2, max2)
    return min2 + ((x - min1) / (max1 - min1)) * (max2 - min2)
end

---@param x number
---@param alignment number
function math.align(x, alignment)
	local off = (alignment - (x % alignment)) % alignment
	return x + off, off
end

-- Take in a binary and turn it into a GUID
-- Bin can be above 16 bytes.
-- If bin is less than 16 bytes, it is padded with 0s
---@param bin string
function string.binToGUID(bin)
    local digits4 = "0123456789abcdef"

    local base16d = ""
    for i=1,16 do
        local byte = string.byte(bin, i, i)
        if not byte then byte = 0 end
        local upper = math.floor(byte / 16) + 1
        local lower = byte % 16 + 1
        base16d = base16d .. digits4:sub(upper, upper) .. digits4:sub(lower, lower)
    end

    local guid = base16d:sub(1, 8) .. "-"
        .. base16d:sub(9, 12) .. "-"
        .. base16d:sub(13, 16) .. "-"
        .. base16d:sub(17, 20) .. "-"
        .. base16d:sub(21)

    return guid
end

function string.randomGUID()
	local buf = ""
	for _=1,16 do buf = buf .. string.char(math.random(0, 255)) end
	return string.binToGUID(buf)
end

---@param t number
function string.uptimefmt(t)
	local hours = math.floor(t / 3600)
	local mins = math.floor(t / 60) % 60
	local secs = t % 60

	return string.format("%02d:%02d:%02.3f", hours, mins, secs)
end

---@param t number
function string.boottimefmt(t)
	local hours = math.floor(t / 3600)
	local mins = math.floor(t / 60) % 60
	local secs = t % 60

	return string.format("%02dh%02dm%02.3fs", hours, mins, secs)
end

---@param name string
---@param path string
---@param sep? string
---@param rep? string
---@return string? filename, string? errmsg
function package.searchpath(name, path, sep, rep)
	sep = sep or "."
	rep = rep or "/"

	name = name:gsub("%" .. sep, rep)

	local paths = string.split(path, ';')

	for _, p in ipairs(paths) do
		local toCheck = p:gsub("%?", name)
		if syscall("exists", toCheck) then
			return toCheck
		end
	end
end

function dofile(filename, ...)
	return assert(loadfile(filename))(...)
end

function loadfile(filename, mode, env)
	local code, err = readfile(filename)
	if not code then return nil, err end
	if code:sub(1,2) == "#!" then
		-- shebang!
		local ln = string.find(code, "\n") or #code
		code = code:sub(ln+1)
	end
	return load(code, "=" .. filename, mode, env)
end

---@param bufsize? integer
---@return string?, string?
function readfile(filename, bufsize)
	local fd, err = syscall("open", filename, "r")
	if err then return nil, err end

	local code = {}
	while true do
		local data, err2 = syscall("read", fd, bufsize or math.huge)
		if err2 then
			syscall("close", fd)
			return nil, err2
		end
		if not data then break end
		table.insert(code, data)
	end

	syscall("close", fd)
	return table.concat(code)
end

---@param data string
---@return boolean, string?
function writefile(filename, data)
	local fd, err = syscall("open", filename, "w")
	if not fd then return false, err end

	local ok, err2 = syscall("write", fd, data)
	syscall("close", fd)
	return ok, err2
end
--- Non-buffered event stream
--- Use listeners to ensure all events are processed and none are skipped
--- Based off OpenOS' event library, but with many subtle differences

Kocos.event = {}

---@type function[]
Kocos.event.listeners = {}
---@type table<integer, {times: integer, interval: number, deadline: number, func: function}>
Kocos.event.timers = {}

function Kocos.event.notifyListeners(...)
	for _, func in ipairs(Kocos.event.listeners) do
		local ok, err = xpcall(func, debug.traceback, ...)
		if not ok then
			Kocos.printkf(Kocos.L_ERROR, "Signal handler error: %s", err)
		end
	end
end

function Kocos.event.listen(func)
	table.insert(Kocos.event.listeners, func)
end

function Kocos.event.forget(func)
	for i=#Kocos.event.listeners, 1, -1 do
		if Kocos.event.listeners[i] == func then
			table.remove(Kocos.event.listeners, i)
		end
	end
end

function Kocos.event.processTimers()
	local toCancel = {}

	for id, timer in pairs(Kocos.event.timers) do
		local now = computer.uptime()
		if timer.deadline <= now then
			timer.times = timer.times - 1
			timer.deadline = now + timer.interval
			timer.func()
		end
		if timer.times < 1 then
			table.insert(toCancel, id)
		end
	end

	for _, id in ipairs(toCancel) do Kocos.event.cancel(id) end
end

function Kocos.event.minTimeTilNextTimer(timeleft)
	for _, timer in pairs(Kocos.event.timers) do
		local timerleft = timer.deadline - computer.uptime()
		timeleft = math.min(timeleft, timerleft)
	end
	return math.max(timeleft, Kocos.args.minEventPoll or 0)
end

---@param interval number
---@param func function
---@param times? integer
function Kocos.event.timer(interval, func, times)
	times = times or 1

	local id = #Kocos.event.timers
	while Kocos.event.timers[id] do id = id + 1 end
	Kocos.event.timers[id] = {
		interval = interval,
		func = func,
		times = times,
		deadline = computer.uptime() + interval,
	}
	return id
end

function Kocos.event.cancel(id)
	Kocos.event.timers[id] = nil
end

---@param timeout? number
function Kocos.event.pull(timeout)
	timeout = timeout or (Kocos.args.pollInterval or 0)
	local deadline = computer.uptime() + timeout

	while true do
		local now = computer.uptime()
		local timeleft = Kocos.event.minTimeTilNextTimer(deadline - now)
		local s = {computer.pullSignal(timeleft)}
		Kocos.event.processTimers()
		if s[1] then
			Kocos.event.notifyListeners(table.unpack(s))
			return table.unpack(s)
		end
		if now > deadline then return end
	end
end

---@type fun(ev: string, ...)
Kocos.event.push = computer.pushSignal
-- virtual components

do
	local cmethods = component.methods
	local cinvoke = component.invoke
	local cproxy = component.proxy
	local cfields = component.fields
	local cdoc = component.doc
	local cslot = component.slot
	local ctype = component.type
	local clist = component.list

	---@class Kocos.vdevice
	---@field address string
	---@field type string
	---@field slot integer
	---@field methods table<string, {getter: boolean, setter: boolean, direct: boolean, doc?: string}>
	---@field invoke fun(method: string, ...): ...

	---@type table<string, Kocos.vdevice>
	local vComponents = {}

	--- Code copied from or heavily based off https://github.com/MightyPirates/OpenComputers/blob/master-MC1.7.10/src/main/resources/assets/opencomputers/lua/machine.lua
	local vproxyCache = setmetatable({}, {__mode="v"})

	local componentProxy = {
	  __index = function(self, key)
		if self.fields[key] and self.fields[key].getter then
		  return self.invoke(key)
		end
	  end,
	  __newindex = function(self, key, value)
		if self.fields[key] and self.fields[key].setter then
		  return self.invoke(key, value)
		elseif self.fields[key] and self.fields[key].getter then
		  error("field is read-only")
		else
		  rawset(self, key, value)
		end
	  end,
	  __pairs = function(self)
		local keyProxy, keyField, value
		return function()
		  if not keyField then
			repeat
			  keyProxy, value = next(self, keyProxy)
			until not keyProxy or keyProxy ~= "fields"
		  end
		  if not keyProxy then
			keyField, value = next(self.fields, keyField)
		  end
		  return keyProxy or keyField, value
		end
	  end
	}

	local componentCallback = {
	  __call = function(self, ...)
		return component.invoke(self.address, self.name, ...)
	  end,
	  __tostring = function(self)
		return component.doc(self.address, self.name) or "function"
	  end
	}

	---@param vdev Kocos.vdevice
	function component.add(vdev)
		if component.type(vdev.address) then return end
		vComponents[vdev.address] = vdev
		Kocos.event.push("component_added", vdev.address, vdev.type)
		return vdev.address
	end

	---@param address string
	function component.remove(address)
		local v = vComponents[address]
		if not v then return end
		vComponents[address] = nil
		Kocos.event.push("component_removed", v.address, v.type)
	end

	---@param address string
	function component.isVirtual(address)
		return vComponents[address] ~= nil
	end

	---@param address string
	function component.slot(address)
		checkArg(1, address, "string")
		local v = vComponents[address]
		if v then
			return v.slot
		end
		return cslot(address)
	end

	---@param address string
	function component.type(address)
		checkArg(1, address, "string")
		local v = vComponents[address]
		if v then
			return v.type
		end
		return ctype(address)
	end

	---@param address string
	---@param method string
	function component.doc(address, method)
		checkArg(1, address, "string")
		checkArg(2, method, "string")
		local v = vComponents[address]
		if v then
			if not v.methods[method] then return nil, "no such method" end
			return v.methods[method].doc
		end
		return cdoc(address, method)
	end

	---@param address string
	function component.methods(address)
		checkArg(1, address, "string")
		local v = vComponents[address]
		if v then
			local methods = {}
			for name, m in pairs(v.methods) do
				if not m.getter and not m.setter then
					methods[name] = m.direct
				end
			end
			return methods
		end
		return cmethods(address)
	end

	---@param address string
	function component.fields(address)
		checkArg(1, address, "string")
		local v = vComponents[address]
		if v then
			local fields = {}
			for name, m in pairs(v.methods) do
				if m.getter or m.setter then
					-- no overwriting kernel memory for you!
					fields[name] = {getter = m.getter, setter = m.setter}
				end
			end
			return fields
		end
		return cfields(address)
	end

	---@param address string
	---@param method string
	---@return ...
	function component.invoke(address, method, ...)
		checkArg(1, address, "string")
		checkArg(2, method, "string")
		local v = vComponents[address]
		if v then
			local m = v.methods[method]
			if not m then return nil, "no such method" end
			if m.getter or m.setter then return nil, "no such method" end -- its a field!
			return v.invoke(method, ...)
		end
		return cinvoke(address, method, ...)
	end

	function component.proxy(address)
		if not component.isVirtual(address) then return cproxy(address) end
		local type, reason = component.type(address)
		if not type then
		  return nil, reason
		end
		local slot, reason = component.slot(address)
		if not slot then
		  return nil, reason
		end
		if vproxyCache[address] then
		  return vproxyCache[address]
		end
		local fields, reason = component.fields(address)
		if not fields then
		  return nil, reason
		end
		local proxy = {address = address, type = type, slot = slot, fields = fields, invoke = vComponents[address].invoke}
		local methods, reason = component.methods(address)
		if not methods then
		  return nil, reason
		end
		for method in pairs(methods) do
			proxy[method] = setmetatable({address=address,name=method}, componentCallback)
		end
		setmetatable(proxy, componentProxy)
		vproxyCache[address] = proxy
		return proxy
	end

	---@param filter? string
	---@param exact? boolean
	function component.list(filter, exact)
		local t = clist(filter, exact)
		for addr, v in pairs(vComponents) do
			if filter then
				if exact then
					if v.type == filter then
						t[addr] = v.type
					end
				else
					if string.match(v.type, filter) then
						t[addr] = v.type
					end
				end
			else
				t[addr] = v.type
			end
		end
		return t
	end
end

local primCache = {}

function component._defaultHandler(ev, addr, type)
	if ev == "component_removed" then
		if not primCache[type] then return end
		if primCache[type].address ~= addr then return end
		primCache[type] = nil
	end
end

setmetatable(component, {__index = function(t, key)
	if type(key) ~= "string" then return end
	return component.getPrimary(key)
end})

---@param type string
---@return Kocos.device?
function component.getPrimary(type)
	if primCache[type] then return primCache[type] end

	local addr = component.list(type, true)()
	if not addr then return end
	primCache[type] = component.proxy(addr)
	return primCache[type]
end

---@param type string
function component.hasPrimary(type)
	return component.getPrimary(type) ~= nil
end

Kocos.event.listen(component._defaultHandler)
Kocos.L_DEBUG = 0
Kocos.L_INFO = 1
Kocos.L_AUTOFIX = 2
Kocos.L_WARN = 3
Kocos.L_ERROR = 4
Kocos.L_PANIC = 5

local oc = component.list("ocelot")()

---@param text string
function Kocos.scr_write(text)
	-- No screen available
end

---@param len integer
---@return string?
function Kocos.scr_read(len)
	return nil -- no input source available
end

function Kocos._scr_reader(...)
	-- nothing to react to
end

---@return string[]
function Kocos.scr_addrs()
	return {}
end

---@param action string
---@param ... any
---@return ...
function Kocos.scr_ioctl(action, ...)

end

local gpu, screen = component.list("gpu")(), component.list("screen")()

if gpu and screen then
	component.invoke(gpu, "bind", screen)

	local x, y = 1, 1
	local w, h = component.invoke(gpu, "maxResolution")

	local buf = ""
	local keybuf = ""

	local targetPid

	local function flush()
		component.invoke(gpu, "set", x - #buf, y, buf)
		buf = ""
	end

	local function color(r, g, b)
		return r * 0x10000 + g * 0x100 + b
	end

	---@type integer?
	local blinkTimer = nil
	local lightOn = false

	local function swapColors()
		local fg = component.invoke(gpu, "getForeground")
		local bg = component.invoke(gpu, "getBackground")
		component.invoke(gpu, "setForeground", bg)
		component.invoke(gpu, "setBackground", fg)
	end

	local function showCursor()
		if lightOn then return end
		lightOn = true
		swapColors()
		local c = component.invoke(gpu, "get", x, y)
		component.invoke(gpu, "set", x, y, c)
	end

	local function hideCursor()
		if not lightOn then return end
		lightOn = false
		swapColors()
		local c = component.invoke(gpu, "get", x, y)
		component.invoke(gpu, "set", x, y, c)
	end

	local function toggleCursor()
		if lightOn then
			hideCursor()
		else
			showCursor()
		end
	end

	local function disableBlink()
		if not blinkTimer then return end
		Kocos.event.cancel(blinkTimer)
		blinkTimer = nil
	end

	local function enableBlink()
		if blinkTimer then return end
		blinkTimer = Kocos.event.timer(0.5, function()
			if Kocos.disableScreen then disableBlink() end
			toggleCursor()
		end, math.huge)
	end

	local stdClrs = Kocos.args.termStdColors or {
		-- taken from https://en.wikipedia.org/wiki/ANSI_escape_code#Control_Sequence_Introducer_commands
		-- Mix of VS Code and VGA.
		-- BG is auto-computed.
		[30] = color(0, 0, 0), -- black
		[31] = color(205, 49, 49), -- red
		[32] = color(13, 188, 121), -- green
		[33] = color(229, 229, 16), -- yellow
		[34] = color(36, 114, 200), -- blue
		[35] = color(188, 63, 188), -- magenta
		[36] = color(17, 168, 205), -- cyan
		[37] = color(229, 229, 229), -- white
		[90] = color(85, 85, 85), -- bright black (gray)
		[91] = color(255, 85, 85), -- bright red
		[92] = color(85, 255, 85), -- bright green
		[93] = color(255, 255, 85), -- bright yellow
		[94] = color(59, 142, 234), -- bright blue
		[95] = color(255, 85, 255), -- bright magenta
		[96] = color(85, 255, 255), -- bright cyan
		[97] = color(255, 255, 255), -- bright white
	}

	local defaultFg = Kocos.args.termDefaultFg or stdClrs[37]
	local defaultBg = Kocos.args.termDefaultBg or stdClrs[30]

	component.invoke(gpu, "setForeground", defaultFg)
	component.invoke(gpu, "setBackground", defaultBg)

	component.invoke(gpu, "setResolution", w, h)
	component.invoke(gpu, "fill", 1, 1, w, h, " ")

	local color256 = {
		[0] = stdClrs[30],
		[1] = stdClrs[31],
		[2] = stdClrs[32],
		[3] = stdClrs[33],
		[4] = stdClrs[34],
		[5] = stdClrs[35],
		[6] = stdClrs[36],
		[7] = stdClrs[37],
		[8] = stdClrs[90],
		[9] = stdClrs[91],
		[10] = stdClrs[92],
		[11] = stdClrs[93],
		[12] = stdClrs[94],
		[13] = stdClrs[95],
		[14] = stdClrs[96],
		[15] = stdClrs[97],
	}

	local esc = nil

	for red=0,5 do
		for green=0,5 do
			for blue=0,5 do
				local code = 16 + (red * 36) + (green * 6) + blue
				local r, g, b = 0, 0, 0
				if red ~= 0 then r = red * 40 + 55 end
				if green ~= 0 then g = green * 40 + 55 end
				if blue ~= 0 then b = blue * 40 + 55 end
				color256[code] = color(r, g, b)
			end
		end
	end

	for gray=0, 23 do
		local level = gray * 10 + 8
		local code = 232 + gray
		color256[code] = color(level, level, level)
	end

	local isKeyUpEnabled = false

	local sx, sy = 1, 1

	local MAX_ESC = 1*1024

	---@param contents string
	---@param action string
	local function doCSI(contents, action)
		-- CSIs can have "intermediate bytes", for some fucking reason
		local params = ""

		while #contents > 0 and contents:byte() >= 0x30 and contents:byte() <= 0x3F do
			params = params .. contents:sub(1, 1)
			contents = contents:sub(2)
		end

		---@type (number?)[]
		local nums = string.split(params, ";")
		for i=1,#nums do nums[i] = tonumber(nums[i]) end

		if action == "A" then
			local n = nums[1] or 1
			y = math.clamp(y - n, 1, h)
			return
		end
		if action == "B" then
			local n = nums[1] or 1
			y = math.clamp(y + n, 1, h)
			return
		end
		if action == "C" then
			local n = nums[1] or 1
			x = math.clamp(x + n, 1, w)
			return
		end
		if action == "D" then
			local n = nums[1] or 1
			x = math.clamp(x - n, 1, w)
			return
		end
		if action == "E" then
			local n = nums[1] or 1
			x = 1
			y = math.clamp(y + n, 1, h)
			return
		end
		if action == "F" then
			local n = nums[1] or 1
			x = 1
			y = math.clamp(y - n, 1, h)
			return
		end
		if action == "G" then
			local n = nums[1] or 1
			x = math.clamp(n, 1, w)
			return
		end
		if action == "H" then
			local n = nums[1] or 1
			local m = nums[2] or 1
			x = math.clamp(n, 1, w)
			y = math.clamp(m, 1, h)
			return
		end
		if action == "J" then
			local n = nums[1] or 0
			if n == 0 then
				component.invoke(gpu, "fill", x, y, w - x + 1, 1, " ")
				component.invoke(gpu, "fill", 1, y+1, 1, h-y, " ")
			elseif n == 1 then
				component.invoke(gpu, "fill", 1, 1, 1, y-1, " ")
				component.invoke(gpu, "fill", 1, y, x, 1, " ")
			elseif n == 2 then
				component.invoke(gpu, "fill", 1, 1, w, h, " ")
			end
			return
		end
		if action == "K" then
			local n = nums[1] or 0
			if n == 0 then
				component.invoke(gpu, "fill", x, y, w - x + 1, 1, " ")
			elseif n == 1 then
				component.invoke(gpu, "fill", 1, y, x, 1, " ")
			elseif n == 2 then
				component.invoke(gpu, "fill", 1, y, w, 1, " ")
			end
			return
		end
		if action == "S" then
			local n = nums[1] or 1
			component.invoke(gpu, "copy", 1, 1, w, h, 0, n)
			component.invoke(gpu, "fill", 1, 1, w, n, " ")
			y = math.clamp(y - n, 1, h)
			return
		end
		if action == "T" then
			local n = nums[1] or 1
			component.invoke(gpu, "copy", 1, 1, w, h, 0, -n)
			component.invoke(gpu, "fill", 1, h-n+1, w, n, " ")
			y = math.clamp(y - n, 1, h)
			return
		end
		if action == "m" then
			---@cast nums (number?)[]
			local function pop()
				return table.remove(nums, 1) or 0
			end
			if #nums == 0 then nums = {0} end
			while #nums > 0 do
				local op = pop()
				if op == 0 then
					component.invoke(gpu, "setForeground", defaultFg)
					component.invoke(gpu, "setBackground", defaultBg)
				elseif op == 7 then
					swapColors()
				elseif op == 8 then
					-- TODO: conceal
				elseif op == 28 then
					-- TODO: conceal
				elseif op >= 30 and op <= 37 then
					component.invoke(gpu, "setForeground", stdClrs[op])
				elseif op >= 90 and op <= 97 then
					component.invoke(gpu, "setForeground", stdClrs[op])
				elseif op >= 40 and op <= 47 then
					component.invoke(gpu, "setBackground", stdClrs[op-10])
				elseif op >= 100 and op <= 107 then
					component.invoke(gpu, "setBackground", stdClrs[op-10])
				elseif op == 38 then
					local clr = defaultFg
					local n = pop()
					if n == 5 then
						clr = color256[pop()]
					elseif n == 2 then
						local r = pop()
						local g = pop()
						local b = pop()
						clr = color(r,g,b)
					end
					component.invoke(gpu, "setForeground", clr)
				elseif op == 48 then
					local clr = defaultBg
					local n = pop()
					if n == 5 then
						clr = color256[pop()]
					elseif n == 2 then
						local r = pop()
						local g = pop()
						local b = pop()
						clr = color(r,g,b)
					end
					component.invoke(gpu, "setBackground", clr)
				elseif op == 39 then
					component.invoke(gpu, "setForeground", defaultFg)
				elseif op == 49 then
					component.invoke(gpu, "setBackground", defaultBg)
				end
			end
			return
		end
		if action == "n" then
			if nums[1] == 6 then
				keybuf = keybuf .. string.format("\x1b[%d;%dR", x, y)
				return
			end
			if nums[1] == 7 then
				keybuf = keybuf .. string.format("\x1b[%d;%dR", w, h)
				return
			end
			if nums[1] == 8 then
				local mw, mh = component.invoke(gpu, "maxResolution")
				keybuf = keybuf .. string.format("\x1b[%d;%dR", mw, mh)
				return
			end
			return
		end
		if action == "i" then
			-- dont care about AUX port
			return
		end
		if action == "h" then
			if params == "?25" then
				enableBlink()
				showCursor()
				return
			end
			if params == "?1004" then
				-- Not applicable
				return
			end
			if params == "?2004" then
				isKeyUpEnabled = true
				return
			end
			return
		end
		if action == "l" then
			if params == "?25" then
				disableBlink()
				hideCursor()
				return
			end
			if params == "?1004" then
				-- Not applicable
				return
			end
			if params == "?2004" then
				isKeyUpEnabled = false
				return
			end
			return
		end
		if action == "U" then
			if nums[1] == 1 then
				component.invoke(gpu, "fill", nums[2] or 1, nums[3] or 1, nums[4] or w, nums[5] or h, unicode.char(nums[6] or 32))
				return
			end
			if nums[1] == 2 then
				component.invoke(gpu, "copy", nums[2] or 1, nums[3] or 1, nums[4] or w, nums[5] or h, nums[6] or 0, nums[7] or 0)
				return
			end
			if nums[1] == 3 then
				local _w = nums[2] or w
				local _h = nums[3] or h
				if component.invoke(gpu, "setResolution", _w, _h) then
					w = _w
					h = _h
				end
				return
			end
			if nums[1] == 4 then
				local x = nums[2] or x
				local y = nums[3] or y
				local c, f, g = component.invoke(gpu, "get", x, y)
				keybuf = keybuf .. string.format("\x1b[%d;%d;%dR", string.byte(c), f, g)
				return
			end
			return
		end
		if action == "v" then
			if nums[1] == 1 then
				local free = component.invoke(gpu, "freeMemory") or 0
				local total = component.invoke(gpu, "totalMemory") or 0
				keybuf = keybuf .. string.format("\x1b[%d;%dR", free, total)
				return
			end
			return
		end
	end

	---@param cmd string
	local function doOSC(cmd)
		if cmd:sub(1, 2) == "0;" then
			Kocos.printk(Kocos.L_WARN, cmd:sub(3))
		end
		if cmd:sub(1, 2) == "1;" then
			local ok, _, cx, cy, msg = string.find(cmd:sub(3), "([%d+]);([%d+]);(.*)")
			if ok then
				component.invoke(gpu, "set", tonumber(cx) or x, tonumber(cy) or y, msg)
			end
		end
	end

	local lastbeep = 0
	local beepinterval = 5

	local function putc(c)
		if esc then
			if #esc == MAX_ESC then
				esc = nil -- yeah no
				return
			end
			if c == "7" and #esc == 0 then
				sx, sy = x, y
				esc = nil
				return
			end
			if c == "8" and #esc == 0 then
				x, y = sx, sy
				esc = nil
				return
			end
			if c == ']' and #esc == 0 then
				esc = ']' -- OSC!!!
				return
			end
			if c == '[' and #esc == 0 then
				esc = '[' -- CSI!!!
				return
			end
			if esc:sub(1, 1) == '[' then
				-- CSI
				if c:byte() >= 0x40 and c:byte() <= 0x7E then
					local ok, err = pcall(doCSI, esc:sub(2), c)
					esc = nil
					if not ok then
						Kocos.printk(Kocos.L_ERROR, err)
					end
					return
				end
				esc = esc .. c
				return
			end
			if esc:sub(1, 1) == ']' then
				-- OSC
				esc = esc .. c
				local terms = {"\a", "\x1b\\"}
				for _, term in ipairs(terms) do
					if esc:sub(-#term) == term then
						local ok, err = pcall(doOSC, esc:sub(2, -#term - 1))
						esc = nil
						if not ok then
							Kocos.printk(Kocos.L_ERROR, err)
						end
						return
					end
				end
				return
			end
			esc = nil -- bad escape
			return
		end
		if c == "\n" then
			flush()
			y = y + 1
			x = 1
		elseif c == "\r" then
			flush()
			x = 1
		elseif c == "\t" then
			flush()
			x = x + 4
		elseif c == "\a" then
			flush()
			local now = computer.uptime()
			-- super slow so we cap it
			if now - lastbeep > beepinterval then
				--computer.beep(200, 0.01) -- just super slow
				lastbeep = now
			end
		elseif c == "\b" then
			flush()
			if x > 1 then
				x = x - 1
				component.invoke(gpu, "set", x, y, " ")
			end
		elseif c == "\x1b" then
			flush()
			esc = ""
		else
			buf = buf .. c
			x = x + 1
		end

		if x > w then
			flush()
			x = 1
			y = y + 1
		end

		if y > h then
			component.invoke(gpu, "copy", 1, 2, w, h-1, 0, -1)
			y = h
			component.invoke(gpu, "fill", 1, y, w, 1, " ")
		end
	end

	function Kocos.scr_write(text)
		if Kocos.disableScreen then return end
		hideCursor()
		for i=1,unicode.len(text) do
			putc(unicode.sub(text, i, i))
		end
		flush()
	end

	local keyboard = component.invoke(screen, "getKeyboards")[1]

	local function isTerminalPrintable(char)
		return (char >= 3 and char <= 20) or (char >= 32)
	end

	local keysHeld = {}

	function Kocos._scr_reader(ev, kbAddr, chr, cod)
		if Kocos.disableScreen then return end
		if kbAddr ~= keyboard then return end
		local mods = 0
		local ctrl = false
		if keysHeld[0x2A] or keysHeld[0x36] then -- shift
			mods = mods + 1
		end
		if keysHeld[0x38] or keysHeld[0xB8] then -- alt / menu
			mods = mods + 2
		end
		if keysHeld[0x1D] or keysHeld[0x9D] then -- control
			mods = mods + 4
			ctrl = true
		end
		if keysHeld[0] then -- meta
			mods = mods + 8
		end
		if ev == "key_down" then
			keysHeld[cod] = true
			local target = Kocos.process.allProcs[targetPid]
			if ctrl then
				-- to fix possible complications on other environments
				if cod == 0x20 then
					keybuf = keybuf .. string.char(4) -- Ctrl-D
					return
				end
				if cod == 0x2E then -- Ctrl-C
					if target then
						Kocos.process.raise(target, Kocos.process.SIGINT)
					else
						keybuf = keybuf .. string.char(3)
					end
					return
				end
			end
			if chr == 3 then -- also Ctrl-C
				if target then
					Kocos.process.raise(target, Kocos.process.SIGINT)
				else
					keybuf = keybuf .. string.char(3)
				end
				return
			end
			if isTerminalPrintable(chr) then
				keybuf = keybuf .. unicode.char(chr)
				return
			end
			if chr == 0x1b then
				keybuf = keybuf .. "\x1b\x1b"
				return
			end
			if mods == 0 then
				keybuf = keybuf .. string.format("\x1b[%d;%d~", chr, cod)
			else
				keybuf = keybuf .. string.format("\x1b[%d;%d;%d~", chr, cod, mods)
			end
			return
		end
		if ev == "key_up" then
			keysHeld[cod] = false
			if isKeyUpEnabled then
				if mods == 0 then
					keybuf = keybuf .. string.format("\x1b[%d;%d^", chr, cod)
				else
					keybuf = keybuf .. string.format("\x1b[%d;%d;%d^", chr, cod, mods)
				end
			end
			return
		end
		if ev == "clipboard" then
			keybuf = keybuf .. "\x1b[" .. tostring(#chr) .. "|" .. chr
			return
		end
	end

	---@param len integer
	---@return string?
	function Kocos.scr_read(len)
		if Kocos.disableScreen then return end
		len = math.min(len, #keybuf)
		local oldbuf = keybuf:sub(1, len)
		keybuf = keybuf:sub(len+1)
		return oldbuf
	end

	---@return string[]
	function Kocos.scr_addrs()
		return {gpu, screen, keyboard}
	end

	---@param action string
	---@param ... any
	---@return ...
	function Kocos.scr_ioctl(action, ...)
		if action == "setfgpid" then
			targetPid = ...
			return
		end
		if action == "terminfo" then
			local hw_features = {}
			local depth = component.invoke(gpu, "getDepth")
			local hasVRAM = component.invoke(gpu, "totalMemory")

			if depth > 1 then
				table.insert(hw_features, "color")
			end
			if depth > 4 then
				table.insert(hw_features, "truecolor")
			end
			if hasVRAM then
				table.insert(hw_features, "vrambuf")
			end

			return {
				termname = "kocos-vtty-gpu",
				hw = Kocos.scr_addrs(),
				hw_features = hw_features,
				term_features = {
					"ansicolor",
					"256color",
					"truecolor",
					"gpu",
					"vrambuf",
				},
				columns = w,
				lines = h,
			}
		end
		return nil, Kocos.errno.EINVAL
	end
end

Kocos.event.listen(Kocos._scr_reader)

---@param text string
function Kocos.writelog(text)
	-- No version when output available
	if oc and not Kocos.args.noOcelotLog then
		component.invoke(oc, "log", text)
	end
	-- typically done after boot to not fight the kernel logger
	if Kocos.disableScreenLogging then return end
	Kocos.scr_write(text)
end

function Kocos.printk(severity, msg)
	local uptime = computer.uptime()

	Kocos.event.notifyListeners("kocos_log", uptime, severity, msg)

	if Kocos.args.minLog then
		if severity < Kocos.args.minLog then return end
	end

	local names = {
		[Kocos.L_DEBUG] = "DEBUG",
		[Kocos.L_INFO] = "INFO",
		[Kocos.L_AUTOFIX] = "AUTOFIX",
		[Kocos.L_WARN] = "WARN",
		[Kocos.L_ERROR] = "ERROR",
		[Kocos.L_PANIC] = "PANIC",
	}

	local colors = {
		[Kocos.L_DEBUG] = 2,
		[Kocos.L_INFO] = 12,
		[Kocos.L_AUTOFIX] = 8,
		[Kocos.L_WARN] = 3,
		[Kocos.L_ERROR] = 1,
		[Kocos.L_PANIC] = 9,
	}

	local color, reset = "", ""

	color = "\x1b[38;5;" .. tostring(colors[severity] or 0) .. "m"

	reset = "\x1b[0m"

	local rawText = string.format("[%5.3f %s%s%s] %s\n", uptime, color, names[severity] or "UNKNOWN", reset, msg)
	Kocos.writelog(rawText)

	if severity == Kocos.L_PANIC then
		if Kocos.disableDefaultPanicHandler then
			Kocos.event.notifyListeners("kocos_panic", uptime, msg)
			return
		end
		pcall(Kocos.event.pull, 5)
		computer.shutdown(true)
	end
end

function Kocos.printkf(severity, fmt, ...)
	Kocos.printk(severity, string.format(fmt, ...))
end

function Kocos.panick(msg)
	Kocos.printk(Kocos.L_PANIC, msg)
end

function Kocos.panickf(fmt, ...)
	Kocos.panick(string.format(fmt, ...))
end

Kocos.printk(Kocos.L_DEBUG, "printk loaded")
local errno = {}

errno.E2BIG = "too many arguments"
errno.EACCESS = "permission denied"
errno.EAGAIN = "resource temporarily unavailable"
errno.EBADF = "bad file descriptor"
errno.EBADMSG = "bad message"
errno.ECHILD = "no child processes"
errno.EEXIST = "file exists"
errno.EFBIG = "file too large"
errno.EHWPOISON = "critical driver error"
errno.EINVAL = "invalid argument"
errno.EIO = "I/O error"
errno.EISDIR = "is a directory"
errno.ELIBACC = "cannot access shared library"
errno.ELIBBAD = "invalid shared library"
errno.ELIBEXEC = "cannot exec a shared library"
errno.ELOOP = "too many symbolic links"
errno.ENAMETOOLONG = "name too long"
errno.ENODEV = "no such device"
errno.ENOENT = "no such file or directory"
errno.ENOEXEC = "exec format error"
errno.ENOSYS = "invalid syscall"
errno.ENOTBLK = "block device required"
errno.ENOTDIR = "not a directory"
errno.ENOTEMPTY = "directory not empty"
errno.ENOTSOCK = "not a socket"
errno.EPERM = "operation not permitted"
errno.EPIPE = "broken pipe"
errno.EPROTO = "protocol error"
errno.EPROTONOSUPPORT = "protocol not supported"
errno.EPROTOTYPE = "protocol wrong type for socket"
errno.ERESTART = "syscall requires restart"
errno.ESPIPE = "invalid seek"
errno.ESRCH = "no such process"
errno.ESTRPIPE = "streams pipe error"
errno.ETIME = "timer expired"
errno.EUNATCH = "driver not attached"
errno.ENODRIVER = errno.EUNATCH
errno.ETIMEDOUT = "connection timed out"
errno.EROFS = "read-only filesystem"
errno.ENETDOWN = "network is down"
errno.EISCONN = "socket is connected"
errno.ECANCELED = "operation cancelled"
errno.EALREADY = "connection already in progress"
errno.EADDRINUSE = "address already in use"
errno.EADDRNOTAVAIL = "address not available"
errno.EAFNOSUPPORT = "address family not supported"
errno.EXDEV = "invalid cross-device link"
errno.EHOSTISDOWN = "host is unreachable"

Kocos.errno = errno
-- KOCOS drivers are simple functions
-- They are effectively request handlers
-- This is to minimize memory usage

---@type function[]
Kocos.drivers = {}

function Kocos.addDriver(driver)
	table.insert(Kocos.drivers, 1, driver)
	Kocos.event.notifyListeners("driver_added", driver)
end

function Kocos.removeDriver(driver)
	for i=#Kocos.drivers,1, -1 do
		if Kocos.drivers[i] == driver then
			table.remove(Kocos.drivers, i)
		end
	end
	Kocos.event.notifyListeners("driver_removed", driver)
end

Kocos.printk(Kocos.L_DEBUG, "driver system loaded")
do
	Kocos.printk(Kocos.L_DEBUG, "debugger subsystem loaded")

	local event = Kocos.event

	---@param resp string
	local function respond(resp)
		event.push("kgdb_resp", resp)
	end

	---@param fmt string
	local function respondf(fmt, ...)
		respond(string.format(fmt, ...))
	end

	---@type {args: any[], rets?: any[], bt: string, last: table?}?
	_BreakInfo = nil

	function _WRAP_BREAKPOINT(f, name)
		if type(f) == "table" then
			return f.func
		else
			return setmetatable({
				func = f,
			}, {
				__tostring = function() return tostring(f) end,
				__call = function(t, ...)
					_BreakInfo = {args = {...}, bt = debug.traceback(name), last = _BreakInfo}
					respondf("Hit breakpoint %s", name or "unnamed")
					while true do
						local e = Kocos.event.pull(math.huge)
						if e == "kgdb_go" then
							break
						end
					end
					local ret = {f(...)}
					_BreakInfo.rets = ret
					while true do
						local e = Kocos.event.pull(math.huge)
						if e == "kgdb_go" then
							_BreakInfo = _BreakInfo.last
							break
						end
					end
					respondf("Breakpoint %s over", name or "unnamed")
					return table.unpack(ret)
				end,
			})
		end
	end

	---@param ev string
	---@param command string
	event.listen(function(ev, command)
		if ev ~= "kgdb_msg" then return end
		if command == "h" then
			respond([[
h - Display this help page
l <code> - Run Lua code as a statement
x <code> - Run Lua code as an expression (or comma-separated series of expressions) and display results
r - Reboot
R - Shutdown
m - View memory usage
e - View battery status
c - List known device hardware
c <filter> - Like c, except using a fuzzy match identical to component.list()
bp <expression> - Wrap a function to trigger a breakpoint. This will replace the function with a table with the __call metamethod.
bt - Print the backtrace saved from the latest breakpoint
ba - Print the arguments saved from the latest breakpoint
br - Print the returns saved from the latest breakpoint
g - Go, aka, run past breakpoint
gc - Go, but only past the call. Still break on return. br will print the returns
]])
			return
		end
		if command:sub(1, 3) == "bp " then
			local name = command:sub(4)
			local expr = string.format("%s = _WRAP_BREAKPOINT(%s, %q)", name, name, name)
			local f, err = load(expr, "=bp")
			if not f then
				respondf("Error: %s", err)
				return
			end
			local ok, err2 = xpcall(f, debug.traceback)
			if err then
				respondf("Error: %s", err2)
				return
			end
			respondf("Toggled breakpoint %s", name)
			return
		end
		if command == "gc" then
			if _BreakInfo.rets then return respond("Call already resumed") end
			Kocos.event.push("kgdb_go")
			return respond("Call skipped")
		end
		if command == "g" then
			if not _BreakInfo.rets then Kocos.event.push("kgdb_go") end
			Kocos.event.push("kgdb_go")
			return
		end
		if command == "bt" then
			if _BreakInfo then
				return respond(_BreakInfo.bt)
			else
				return respond("No backtrace")
			end
		end
		if command == "ba" then
			if not _BreakInfo then return respond("No breakpoint info") end
			local t = {}
			for i=1,#_BreakInfo.args do t[i] = table.serialize(_BreakInfo.args[i]) end
			return respond(table.concat(t, ", "))
		end
		if command == "br" then
			if not _BreakInfo then return respond("No breakpoint info") end
			if not _BreakInfo.rets then return respond("Call still suspended") end
			local t = {}
			for i=1,#_BreakInfo.rets do t[i] = table.serialize(_BreakInfo.rets[i]) end
			return respond(table.concat(t, ", "))
		end
		if command == "c" or command:sub(1, 2) == "c " then
			local filter = nil
			if command:sub(1, 2) == "c " then
				filter = command:sub(3)
			end
			local buf = {}
			for addr, type in component.list(filter) do
				table.insert(buf, addr .. " = " .. type)
			end
			respond(table.concat(buf, "\n"))
			return
		end
		if command == "m" then
			local total = computer.totalMemory()
			local free = computer.freeMemory()
			local used = total - free
			respondf(
				"Total: %s\nUsed: %s (%3.2f%%)\nFree: %s (%3.2f%%)\n",
				string.memformat(total),
				string.memformat(used),
				used / total * 100,
				string.memformat(free),
				free / total * 100
			)
			return
		end
		if command == "e" then
			local total = computer.maxEnergy()
			local remaining = computer.energy()
			respondf("Energy: %d FE / %d FE (%3.2f%%)", remaining, total, remaining / total * 100)
			return
		end
		if command == "r" then
			respond("Rebooting...")
			Kocos.poweroff(true)
			return
		end
		if command == "R" then
			respond("Shutting down...")
			Kocos.poweroff(false)
			return
		end
		if command:sub(1, 2) == "l " then
			local code = command:sub(3)
			local f, err = load(code, "=kgdb")
			if not f then
				respondf("Error: %s", err)
				return
			end
			local ok, err2 = xpcall(f, debug.traceback)
			if not ok then
				respondf("Error: %s", err2)
				return
			end
			respondf("OK")
			return
		end
		if command == "nproc" then
			local nproc = 0
			for pid in pairs(Kocos.process.allProcs) do
				nproc = nproc + 1
			end
			return respond(tostring(nproc))
		end
		if command == "pids" then
			local pids = {}
			for pid in pairs(Kocos.process.allProcs) do
				table.insert(pids, pid)
			end
			return respond(table.concat(pids, " "))
		end
		if command:sub(1, 2) == "x " then
			local code = command:sub(3)
			local f, err = load("return " .. code, "=kgdb")
			if not f then
				respondf("Error: %s", err)
				return
			end
			local t = {xpcall(f, debug.traceback)}
			if not t[1] then
				respondf("Error: %s", t[2])
				return
			end
			local strs = {}
			for i=2,#t do strs[i-1] = table.serialize(t[i]) end
			if #strs == 0 then strs={"nil"} end
			respond(table.concat(strs, ", "))
			return
		end
	end)

	local kgdb = Kocos.args.debugger

	if kgdb then
		local kgdbType = component.type(kgdb) or "unknown"
		Kocos.printk(Kocos.L_DEBUG, "Using debugger: " .. kgdb .. " (" .. kgdbType .. ")")
		if kgdbType == "ocelot" then
			event.listen(function(ev, hw, msg)
				if ev == "ocelot_message" and hw == kgdb then
					event.push("kgdb_msg", msg)
				end
				if ev == "kgdb_resp" then
					component.invoke(kgdb, "log", "[KGDB] " .. hw)
				end
			end)
		elseif kgdbType == "tunnel" then
			-- TODO: kgdb over tunnels
		elseif kgdbType == "modem" then
			-- TODO: kgdb over modems
		end

		respond("debugger connection established")
	else
		Kocos.printk(Kocos.L_DEBUG, "No debugger selected")
	end
end
do

---@class Kocos.ramfs.node
---@field fileData string?
---@field items table<string, Kocos.ramfs.node>?

---@class Kocos.ramfs.file
---@field mode "r"|"w"|"a"
---@field offset integer
---@field node Kocos.ramfs.node

---@class Kocos.ramfs
---@field label string?
---@field readonly boolean
---@field fds table<integer, Kocos.ramfs.file>
---@field image Kocos.ramfs.node

---@param ramfs Kocos.ramfs
---@param path string[]
---@return Kocos.ramfs.node?
local function processPathParts(ramfs, path)
	local node = ramfs.image
	while #path > 0 do
		local name = table.remove(path, 1)
		if not node.items then return end
		node = node.items[name]
		if not node then return end
	end
	return node
end

---@param ramfs Kocos.ramfs
---@param path string
---@return Kocos.ramfs.node?
local function processPath(ramfs, path)
	local s = string.split(Kocos.fs.canonical(path):sub(2), "/")
	return processPathParts(ramfs, s)
end

---@param ramfs Kocos.ramfs
---@param path string
---@return Kocos.ramfs.node?, string
local function processParentPath(ramfs, path)
	local s = string.split(Kocos.fs.canonical(path):sub(2), "/")
	local name = s[#s]
	s[#s] = nil
	return processPathParts(ramfs, s), name
end

---@param ramfs Kocos.ramfs
---@param address? string
function Kocos.addRamfsComponent(ramfs, address)
	address = address or string.randomGUID()
	return component.add {
		address = address,
		type = "filesystem",
		slot = -1,
		methods = {
			spaceUsed = {direct = true},
			spaceTotal = {direct = true},
			getLabel = {direct = true},
			setLabel = {direct = true},
			exists = {direct = true},
			size = {direct = true},
			list = {direct = true},
			isDirectory = {direct = true},
			isReadOnly = {direct = true},
			lastModified = {direct = true},
			makeDirectory = {direct = true},
			open = {direct = true},
			write = {direct = true},
			read = {direct = true},
			seek = {direct = true},
			close = {direct = true},
			remove = {direct = true},
			rename = {direct = true},
		},
		invoke = function(method, ...)
			if method == "spaceUsed" then
				return computer.totalMemory() - computer.freeMemory()
			end
			if method == "spaceTotal" then
				return computer.totalMemory()
			end
			if method == "getLabel" then
				return ramfs.label
			end
			if method == "setLabel" then
				ramfs.label = tostring((...))
				return ramfs.label
			end
			if method == "exists" then
				local p = ...
				if p == "" then return true end
				return processPath(ramfs, p) ~= nil
			end
			if method == "size" then
				local p = ...
				if p == "" then return 0 end
				local node = processPath(ramfs, p)
				if not node then return 0 end
				if not node.fileData then return 0 end
				return #node.fileData
			end
			if method == "list" then
				local p = ...
				local node = p == "" and ramfs.image or processPath(ramfs, p)
				if not node then return nil, "no such file" end
				if not node.items then return end
				local items = {}
				for name, child in pairs(node.items) do
					if child.items then
						table.insert(items, name .. "/")
					else
						table.insert(items, name)
					end
				end
				return items
			end
			if method == "isDirectory" then
				local p = ...
				if p == "" then return true end
				local node = processPath(ramfs, p)
				if not node then return false end
				return node.items ~= nil
			end
			if method == "isReadOnly" then
				return ramfs.readonly
			end
			if method == "lastModified" then return 0 end
			if method == "makeDirectory" then
				local p = ...
				local parent, name = processParentPath(ramfs, p)
				if not parent then
					return false, p
				end
				if not parent.items then
					return false, p
				end
				parent.items[name] = parent.items[name] or {items={}}
				return true
			end
			if method == "open" then
				local p, m = ...
				m = m or "r"
				if ramfs.readonly and m ~= "r" then
					return nil, "readonly"
				end
				local n = processPath(ramfs, p)
				if m == "r" and not n then return nil, p end
				if not n then
					if ramfs.readonly then
						return nil, "readonly"
					end
					n = {
						fileData = "",
					}
					local parent, name = processParentPath(ramfs, p)
					if not parent then
						return nil, p
					end
					if not parent.items then
						return nil, p
					end
					parent.items[name] = n
				end
				if not n.fileData then return nil, "is a directory" end
				local fd = #ramfs.fds+1
				ramfs.fds[fd] = {
					mode = m,
					offset = m == "a" and #n.fileData or 0,
					node = n,
				}
				if m == "w" then
					n.fileData = ""
				end
				return fd
			end
			if method == "write" then
				local fd, data = ...
				local f = ramfs.fds[fd]
				if not f then return false, "bad file" end
				if f.mode == "r" then return false, "bad file" end
				local buf = f.node.fileData or ""
				if f.mode == "a" then f.offset = #buf end
				buf = buf:sub(1, f.offset) .. data .. buf:sub(f.offset+#data)
				f.node.fileData = buf
				f.offset = f.offset + #data
				return true
			end
			if method == "seek" then
				local fd, whence, off = ...
				whence = whence or "cur"
				off = 0
				off = math.floor(off)
				local f = ramfs.fds[fd]
				if not f then return false, "bad file" end
				local len = #f.node.fileData
				if whence == "set" then
					f.offset = off
				elseif whence == "cur" then
					f.offset = f.offset + off
				elseif whence == "end" then
					f.offset = len - f.offset
				end
				f.offset = math.clamp(f.offset, 0, len)
				return f.offset
			end
			if method == "read" then
				local fd, len = ...
				local f = ramfs.fds[fd]
				if not f then return nil, "bad file" end
				if f.mode ~= "r" then return nil, "bad file" end
				local buf = f.node.fileData or ""
				len = len or #buf
				len = math.min(len, #buf - f.offset)
				if f.offset >= #buf then
					return
				end
				local chunk = buf:sub(f.offset+1, f.offset+len)
				f.offset = f.offset + #chunk
				return chunk
			end
			if method == "close" then
				ramfs.fds[(...)] = nil
				return
			end
			if method == "remove" then
				local p = ...
				local parent, name = processParentPath(ramfs, p)
				if not parent then return false, p end
				if parent.items[name] then
					parent.items[name] = nil
				end
				return true
			end
			if method == "rename" then
				return false, "unsupported"
			end
		end,
	}
end

end
local fs = {}

---@alias Kocos.fs.partitionType "root"|"boot"|"user"
---@alias Kocos.fs.ftype "none"|"regular"|"directory"|"mount"|"blockdev"|"chardev"

fs.FTYPE_NONE = "none"
fs.FTYPE_REGF = "regular"
fs.FTYPE_DIR = "directory"
fs.FTYPE_MNT = "mount"
fs.FTYPE_BLK = "blockdev"
fs.FTYPE_CHR = "chardev"

---@class Kocos.fs.vdrive
---@field address string
---@field type string
---@field getSectorSize fun(): integer
---@field getPlatterCount fun(): integer
---@field getCapacity fun(): integer
---@field readSector fun(index: integer): string
---@field writeSector fun(index: integer, data: string)
--- readByte/writeByte considered harmful, evil and stinky
---@field readByte fun(index: integer): integer
---@field writeByte fun(index: integer, byte: integer)

---@class Kocos.fs.stat
---@field deviceAddress string
---@field deviceType string
---@field inode integer
---@field size integer
---@field lastModified integer
---@field createdAt integer
---@field diskUsed integer
---@field diskTotal integer
--- Currently unused
---@field perms integer
--- Symlinks are not currently supported
---@field linkPath? string

fs.O_NONBLOCK = 1
fs.O_CLOEXEC = 2

fs.F_GETFL = "F_GETFL"
fs.F_SETFL = "F_SETFL"
fs.F_SETCB = "F_SETCB"
fs.F_NOTIF = "F_NOTIF"

-- This one is triggered BEFORE the finalizer is called, thus the resource is still usable in the listener.
fs.EV_CLOSED = "closed"
-- As extra arguments: an integer, containing the length of the data that can be read without blocking
fs.EV_DATAREADY = "data-ready"
-- As extra argumnets: a string, indicating request ID, and an optional string, indicating error if applicable. If no error is passed, operation is assumed to have succeeded atomically.
-- The string ID is conventionally obtained as the error of the successful write.
fs.EV_WRITEDONE = "write-done"

---@class Kocos.fs.FileDescriptor
---@field write? fun(self, data: string): boolean, string?
---@field read? fun(self, amount: integer): string?, string?
---@field seek? fun(self, whence: seekwhence, off: integer): integer?, string?
---@field close? fun(self)
---@field ioctl? fun(self, action: string, ...): ...
---@field flags integer
--- This field should be invoked by the code managing this file descriptor
--- To notify whoever is listening on file system events
--- This is often used for asynchronous I/O, and allows for realtime responses
--- The listener is ONLY automatically informed of *close* events, and thus, **DO NOT MANUALLY NOTIFY OF CLOSE EVENTS**.
---@field listener? function

---@param drive Kocos.device
---@return Kocos.fs.vdrive?
function fs.getVirtualDrive(drive)
	if drive.type == "drive" then return drive end
	if drive.type == "partition" then return drive end
	for _, driver in ipairs(Kocos.drivers) do
		local virt = driver("FS-vdrive", drive)
		if virt then return virt end
	end
end

---@param drive Kocos.device
---@return string[]?
function fs.getPartitionsOf(drive)
	for _, driver in ipairs(Kocos.drivers) do
		local parts = driver("FS-getpartitions", drive)
		if parts then return parts end
	end
end

---@class Kocos.fs.partition: Kocos.fs.vdrive
---@field type "partition"
---@field getDevice fun(): Kocos.device
---@field getDeviceAddress fun(): string
---@field getPartitionType fun(): Kocos.fs.partitionType
---@field getOffset fun(): integer
---@field isReadonly fun(): boolean

---@class Kocos.fs.mountpoint
---@field mountc integer
---@field dev Kocos.device
---@field submounts table<string, Kocos.fs.mountpoint>
---@field fsid string
---@field driverData any
---@field driver? function

--- Maps parition IDs to filesystem mountpoints
---@type table<string, Kocos.fs.mountpoint>
fs.allMounts = {}

---@type Kocos.fs.mountpoint
fs.root = nil

---@param dev Kocos.device
---@return Kocos.fs.mountpoint?
function fs.mount(dev)
	local mountID = dev.address
	if fs.allMounts[mountID] then
		fs.allMounts[mountID].mountc = fs.allMounts[mountID].mountc + 1
		return fs.allMounts[mountID]
	end
	for _, driver in ipairs(Kocos.drivers) do
		local fsid, driverData = driver("FS-mount", dev)
		if fsid then
			fs.allMounts[mountID] = {
				mountc = 1,
				dev = dev,
				submounts = {},
				fsid = fsid,
				driverData = driverData,
				driver = driver,
			}
			return fs.allMounts[mountID]
		end
	end
end

---@param mountpoint Kocos.fs.mountpoint
function fs.unmount(mountpoint)
	if not mountpoint.fsid then return end
	mountpoint.fsid = nil
	mountpoint.mountc = mountpoint.mountc - 1
	if mountpoint.mountc > 0 then return end
	fs.allMounts[mountpoint.dev.address] = nil
	for _, mount in pairs(mountpoint.submounts) do
		fs.unmount(mount)
	end
	if mountpoint.driver then
		mountpoint.driver("FS-unmount", mountpoint.driverData)
	end
end

---@param mountpoint Kocos.fs.mountpoint
function fs.syncMount(mountpoint)
	if mountpoint.driver then
		mountpoint.driver("FS-syncAll", mountpoint.driverData)
	end
end

function fs.sync()
	for _, mount in pairs(fs.allMounts) do
		fs.syncMount(mount)
	end
end

---@param path string
function fs.canonical(path)
	if path:sub(1, 1) == "/" then path = path:sub(2) end
    local parts = string.split(path, "%/")
    local stack = {}

    for _, part in ipairs(parts) do
        if #part > 0 then
            table.insert(stack, part)
            if part == string.rep(".", #part) then
                for _=1,#part do
                    stack[#stack] = nil
                end
            end
        end
    end

    return "/" .. table.concat(stack, "/")
end

function fs.join(...)
	return fs.canonical(table.concat({...}, "/"))
end

---@param path string
---@param root string
function fs.fromRoot(path, root)
	if path == root then
		return "/"
	end
	if root == "/" then
		return path
	end
	return path:sub(#root+1)
end

---@param path string
---@param ignoreLastLink? boolean
---@return Kocos.fs.mountpoint, string
function fs.resolve(path, ignoreLastLink)
	path = fs.canonical(path)
	while path:sub(1,1) == "/" do path = path:sub(2) end
	while path:sub(#path) == "/" do path = path:sub(1, -2) end

	local mountpoint, mountpath = fs.root, path

	while true do
		local done = true
		if mountpoint.submounts[mountpath] then
			if ignoreLastLink then
				break
			end
			return mountpoint.submounts[mountpath], ""
		end

		-- TODO: symlinks

		for m, mp in pairs(mountpoint.submounts) do
			if path:sub(1, #m + 1) == m .. "/" then
				mountpoint = mp
				mountpath = path:sub(#m + 2)
				done = false
			end
		end
		-- TODO: there appears to be a bug where it doesn't loop
		if done then break end
	end

	return mountpoint, mountpath
end

---@param dir string
---@return string[]?, string?
function fs.list(dir)
	if not fs.exists(dir) then
		return nil, Kocos.errno.ENOENT
	end

	local mnt, p = fs.resolve(dir)

	if not mnt.driver then
		return nil, Kocos.errno.ENODRIVER
	end

	local files, err = mnt.driver("FS-listDir", mnt.driverData, p)

	if not files then
		return nil, err or Kocos.errno.EHWPOISON
	end
	return files
end

---@param path string
---@return Kocos.fs.stat?, string?
function fs.stat(path, checklink)
	if not fs.exists(path, checklink) then
		return nil, Kocos.errno.ENOENT
	end

	local mnt, p = fs.resolve(path, checklink)

	if not mnt.driver then
		return nil, Kocos.errno.ENODRIVER
	end

	local stat, err = mnt.driver("FS-stat", mnt.driverData, p)

	if not stat then
		return nil, err or Kocos.errno.EHWPOISON
	end
	return stat
end

---@param path string
---@param mode "r"|"w"|"a"
---@return Kocos.fs.FileDescriptor?, string?
function fs.open(path, mode)
	if not fs.exists(path) then
		return nil, Kocos.errno.ENOENT
	end

	if fs.ftype(path) == fs.FTYPE_DIR then
		return nil, Kocos.errno.EISDIR
	end

	local mnt, p = fs.resolve(path)

	if not mnt.driver then
		return nil, Kocos.errno.ENODRIVER
	end

	return mnt.driver("FS-openFile", mnt.driverData, p, mode)
end

---@param fd Kocos.fs.FileDescriptor
function fs.close(fd)
	if fd.listener then fd.listener(fs.EV_CLOSED) end
	if fd.close then fd:close() end
end

---@param fd Kocos.fs.FileDescriptor
---@param data string
---@return boolean, string?
function fs.write(fd, data)
	if fd.write then
		return fd:write(data)
	end
	return false, Kocos.errno.EBADF
end

---@param fd Kocos.fs.FileDescriptor
---@param len integer
---@return string?, string?
function fs.read(fd, len)
	if fd.read then
		return fd:read(len)
	end
	return nil, Kocos.errno.EBADF
end

---@param fd Kocos.fs.FileDescriptor
---@param whence? seekwhence
---@param off? integer
---@return integer?, string?
function fs.seek(fd, whence, off)
	whence = whence or "set"
	off = off or 0
	if fd.seek then
		return fd:seek(whence, off)
	end
	return nil, Kocos.errno.EBADF
end

---@param fd Kocos.fs.FileDescriptor
---@param action string
---@return ...
function fs.ioctl(fd, action, ...)
	if fd.ioctl then
		return fd:ioctl(action, ...)
	end
	return nil, Kocos.errno.EBADF
end

---@param fd Kocos.fs.FileDescriptor
---@param listener function?
function fs.setlistener(fd, listener)
	fd.listener = listener
end

---@param fd Kocos.fs.FileDescriptor
---@param ev string
function fs.notify(fd, ev, ...)
	if fd.listener then
		fd.listener(ev, ...)
	end
end

---@param reader? fun(self, n: integer): string?, string?
---@param writer? fun(self, data: string): boolean, string?
---@param finalizer? function
---@param ioctl? fun(self, action: string, ...): ...
---@return Kocos.fs.FileDescriptor
function fs.fd_from_rwf(reader, writer, finalizer, ioctl)
	---@type Kocos.fs.FileDescriptor
	return {
		read = reader,
		write = writer,
		close = finalizer,
		ioctl = ioctl,
		flags = 0,
	}
end

---@param path string
---@param perms integer
---@param uid integer
---@param gid integer
---@return boolean?, string?
function fs.touch(path, perms, uid, gid)
	local m, p = fs.resolve(path)
	if not m.driver then
		return nil, Kocos.errno.EHWPOISON
	end
	if fs.ftype(path) == fs.FTYPE_DIR then
		return nil, Kocos.errno.EISDIR
	end
	-- still modifies mtime
	return m.driver("FS-touch", m.driverData, p, perms, uid, gid)
end

---@param path string
---@param perms integer
---@param uid integer
---@param gid integer
---@return boolean?, string?
function fs.mkdir(path, perms, uid, gid)
	local m, p = fs.resolve(path)
	if not m.driver then
		return nil, Kocos.errno.EHWPOISON
	end
	if fs.exists(path, true) then
		return nil, Kocos.errno.EEXIST
	end
	-- still modifies mtime
	return m.driver("FS-mkdir", m.driverData, p, perms, uid, gid)
end

---@param path string
---@return Kocos.fs.ftype?, string?
function fs.ftype(path)
	local m, p = fs.resolve(path, true)
	if not m.driver then
		return nil, Kocos.errno.EHWPOISON
	end
	if m.submounts[p] or p == "" then
		return fs.FTYPE_MNT
	end
	return m.driver("FS-ftype", m.driverData, p)
end

---@param path string
---@return boolean?, string?
function fs.remove(path)
	local ftype, err = fs.ftype(path)
	if not ftype then return nil, err end
	if ftype == fs.FTYPE_NONE then
		return nil, Kocos.errno.ENOENT
	end
	if ftype == fs.FTYPE_MNT then
		return nil, Kocos.errno.EACCESS
	end
	if ftype == fs.FTYPE_DIR then
		local l, err2 = fs.list(path)
		if not l then return nil, err2 end
		if #l > 0 then return nil, Kocos.errno.ENOTEMPTY end
	end
	local m, p = fs.resolve(path)
	if not m.driver then
		return nil, Kocos.errno.EHWPOISON
	end
	return m.driver("FS-remove", m.driverData, p)
end

---@param path string
---@param checklink? boolean
---@return boolean?, string?
function fs.exists(path, checklink)
	local m, p = fs.resolve(path, checklink)
	if not m.driver then
		return nil, Kocos.errno.EHWPOISON
	end
	return m.driver("FS-exists", m.driverData, p)
end

-- super basic managedfs driver
---@param req string
function fs._defaultManagedFS(req, ...)
	if req == "FS-mount" then
		---@type Kocos.device
		local dev = ...
		if dev.type ~= "filesystem" then return end
		return "managedfs", dev
	end
	if req == "FS-listDir" then
		---@type Kocos.device, string
		local dev, path = ...
		if not dev.isDirectory(path) then return nil, Kocos.errno.ENOTDIR end
		return dev.list(path)
	end
	if req == "FS-exists" then
		---@type Kocos.device, string
		local dev, path = ...
		return dev.exists(path)
	end
	if req == "FS-remove" then
		---@type Kocos.device, string
		local dev, path = ...
		return dev.remove(path)
	end
	if req == "FS-ftype" then
		---@type Kocos.device, string
		local dev, path = ...
		if not dev.exists(path) then return fs.FTYPE_NONE end
		if dev.isDirectory(path) then return fs.FTYPE_DIR end
		return fs.FTYPE_REGF
	end
	if req == "FS-touch" then
		---@type Kocos.device, string, integer, integer, integer
		local dev, path, perms, uid, gid = ...
		local f, err = dev.open(path, dev.exists(path) and "w" or "a")
		if not f then return false, err end
		dev.close(f)
		return true
	end
	if req == "FS-mkdir" then
		---@type Kocos.device, string, integer, integer, integer
		local dev, path, perms, uid, gid = ...
		return dev.makeDirectory(path)
	end
	if req == "FS-stat" then
		---@type Kocos.device, string
		local dev, path = ...
		---@type Kocos.fs.stat
		return {
			deviceAddress = dev.address,
			deviceType = dev.type,
			size = dev.size(path) or 0, -- dirs are 0-sized lol
			createdAt = 0,
			lastModified = dev.lastModified(path),
			diskUsed = dev.spaceUsed(),
			diskTotal = dev.spaceTotal(),
			inode = math.random(0, 2^32-1),
			perms = 0,
		}
	end
	if req == "FS-openFile" then
		---@type Kocos.device, string, string
		local dev, path, mode = ...
		if dev.isDirectory(path) then return nil, Kocos.errno.EISDIR end
		local fd, err = dev.open(path, mode)
		if not fd then return nil, err end
		---@type Kocos.fs.FileDescriptor
		return {
			write = function(_, data)
				return dev.write(fd, data)
			end,
			read = function(_, len)
				return dev.read(fd, len)
			end,
			seek = function(_, whence, off)
				return dev.seek(fd, whence, off)
			end,
			close = function()
				dev.close(fd)
			end,
			flags = 0,
		}
	end
end

Kocos.fs = fs

Kocos.printk(Kocos.L_DEBUG, "filesystem subsystem loaded")

Kocos.printk(Kocos.L_INFO, "registering default drivers")
Kocos.addDriver(fs._defaultManagedFS)
Kocos.printk(Kocos.L_INFO, "managedfs driver registered")

-- DevFS abstraction
local fs = Kocos.fs

---@param addr string
local function devfsAddrSuffix(addr)
	return addr:sub(1, 3):upper()
end

local function computeDeviceFiles()
	---@type table<string, string>
	local f = {}
	for addr, type in component.list() do
		local name
		if type == "filesystem" then
			name = "fs" .. devfsAddrSuffix(addr)
		elseif type == "drive" then
			name = "hd" .. devfsAddrSuffix(addr)
		elseif type == "partition" then
			local devaddr = component.invoke(addr, "getDeviceAddress") or "ERR"
			name = "hd" .. devfsAddrSuffix(devaddr) .. "p" .. devfsAddrSuffix(addr)
		elseif type == "serial" then -- imaginary component for all serial comms
			name = "usb" .. devfsAddrSuffix(addr)
		elseif type == "gpu" then
			name = "gpu" .. devfsAddrSuffix(addr)
		elseif type == "tunnel" then
			name = "tnl" .. devfsAddrSuffix(addr)
		elseif type == "screen" then
			name = "screen" .. devfsAddrSuffix(addr)
		elseif type == "eeprom" then
			name = "eeprom" .. devfsAddrSuffix(addr)
		else
			-- TODO: handle the virtual drive abstraction
		end
		if name then f[name] = addr end
	end
	return f
end

---@return string?
local function devfsPathToDev(path)
	if string.startswith(path, "components/") then
		for addr in component.list() do
			if path == "components/" .. addr then
				return addr
			end
		end
		return
	end
	for p, dev in pairs(computeDeviceFiles()) do
		if p == path then return dev end
	end
end

---@param dev string
---@param mode "r"|"a"|"w"
---@return Kocos.fs.FileDescriptor?, string?
local function devfsDevToFD(dev, mode)
	local t = component.type(dev)
	if t == "tunnel" then
		local s, err = Kocos.net.socket("AF_TUNNEL", "dgram")
		if not s then return nil, err end
		local ok, err2 = Kocos.net.connect(s, {address = dev, port = 0})
		if not ok then return nil, err2 end
		s.flags = 1
		---@type Kocos.fs.FileDescriptor
		return {
			flags = 1,
			write = function(_, data)
				if mode == "r" then return false, Kocos.errno.EBADF end
				return Kocos.net.write(s, data)
			end,
			read = function(_, len)
				if mode ~= "r" then return nil, Kocos.errno.EBADF end
				return Kocos.net.read(s, len)
			end,
			close = function()
				Kocos.net.close(s)
			end,
		}
	end
	if t == "serial" then
		---@type Kocos.fs.FileDescriptor
		return {
			flags = 1,
			write = function(_, data)
				if mode == "r" then return false, Kocos.errno.EBADF end
				return component.invoke(dev, "write", data)
			end,
			read = function(_, len)
				if mode ~= "r" then return nil, Kocos.errno.EBADF end
				return component.invoke(dev, "read", len)
			end,
		}
	end
	if t == "drive" or t == "partition" then
		if mode == "a" then
			return nil, "bad mode"
		end
		local d = component.proxy(dev)
		---@cast d Kocos.fs.partition
		local cursor = 0

		---@type Kocos.fs.FileDescriptor
		return {
			flags = 1,
			read = function(_, len)
				if mode ~= "r" then return nil, Kocos.errno.EBADF end
				local cap = d.getCapacity()
				if cursor >= cap then return end
				len = math.min(len, cap - cursor, 4*1024)
				local sectorSize = d.getSectorSize()
				local parts = {}
				local left = len
				while left > 0 do
					local off = cursor % sectorSize
					local sector = assert(d.readSector(1 + math.floor(cursor / sectorSize)))
					-- sub is expensive
					sector = sector:sub(1+off, len+off)
					table.insert(parts, sector)
					left = left - #sector
					cursor = cursor + #sector
				end
				cursor = math.clamp(cursor, 0, cap)
				return table.concat(parts)
			end,
			write = function(_, data)
				if mode == "r" then return false, Kocos.errno.EBADF end
				local cap = d.getCapacity()
				local sectorSize = d.getSectorSize()
				local left = math.min(#data, cap - cursor)
				while left > 0 do
					local written = 0
					if cursor % sectorSize == 0 and left >= sectorSize then
						-- best case scenario possible
						local sec = data:sub(1, sectorSize)
						d.writeSector(1 + cursor / sectorSize, sec)
						written = sectorSize
					else
						-- horrible scenario to be in
						local off = cursor % sectorSize
						local len = math.min(left, sectorSize)
						local secId = 1 + math.floor(cursor / sectorSize)
						local sec = assert(d.readSector(secId))
						sec = sec:sub(1, off) .. data:sub(1, len) .. sec:sub(1+off+len)
						d.writeSector(secId, sec)
						written = len
					end
					data = data:sub(1 + written)
					cursor = cursor + written
					left = left - written
				end
				cursor = math.clamp(cursor, 0, cap)
				return true
			end,
			seek = function(_, whence, off)
				local cap = d.getCapacity()
				if whence == "set" then
					cursor = off
				elseif whence == "cur" then
					cursor = cursor + off
				elseif whence == "end" then
					cursor = cap - off
				end
				cursor = math.clamp(cursor, 0, cap)
				return cursor
			end,
			ioctl = function(_, action, ...)
				if action == "devfs:address" then
					return dev
				end
				if action == "devfs:slot" then
					return component.slot(dev)
				end
				if action == "devfs:type" then
					return component.type(dev)
				end
				if action == "devfs:doc" then
					return component.doc(dev, ...)
				end
				return component.invoke(dev, action, ...)
			end,
		}
	end
	---@type Kocos.fs.FileDescriptor
	return {
		flags = 0,
		ioctl = function(_, method, ...)
				if method == "devfs:address" then
					return dev
				end
				if method == "devfs:slot" then
					return component.slot(dev)
				end
				if method == "devfs:type" then
					return component.type(dev)
				end
				if method == "devfs:doc" then
					return component.doc(dev, ...)
				end
			return component.invoke(dev, method, ...)
		end,
	}
end

---@param path string
---@param mode "r"|"w"|"a"
---@return Kocos.fs.FileDescriptor?, string?
local function devfsMakeFD(path, mode)
	local errno = Kocos.errno
	if path == "null" then
		---@type Kocos.fs.FileDescriptor
		return {
			write = function() return true end,
			read = function() end,
			flags = 0,
		}
	end
	if path == "zero" then
		if mode ~= "r" then return nil, errno.EPERM end
		---@type Kocos.fs.FileDescriptor
		return {
			read = function(_, len)
				if len == math.huge then len = 4096 end
				return string.rep("\0", len)
			end,
			flags = 0,
		}
	end
	if path == "random" then
		if mode ~= "r" then return nil, errno.EPERM end
		---@type Kocos.fs.FileDescriptor
		return {
			read = function(_, len)
				if len == math.huge then len = 4096 end
				local c = ""
				for _=1,len do
					c = c .. string.char(math.random(0, 255))
				end
				return c
			end,
			flags = 0,
		}
	end
	if path == "hex" then
		if mode ~= "r" then return nil, errno.EPERM end
		---@type Kocos.fs.FileDescriptor
		return {
			read = function(_, len)
				if len == math.huge then len = 4096 end
				local c = ""
				local a = "0123456789ABCDEF"
				for _=1,len do
					local i = math.random(1, 16)
					c = c .. a:sub(i, i)
				end
				return c
			end,
			flags = 0,
		}
	end
	if path:sub(1,3) == "std" then
		local fd = Kocos.process["STD" .. path:sub(4):upper()]
		if not fd then return nil, errno.ENOENT end
		---@type Kocos.fs.FileDescriptor
		return {
			write = function(_, data)
				return syscall("write", fd, data)
			end,
			read = function(_, len)
				return syscall("read", fd, len)
			end,
			ioctl = function(_, action, ...)
				return syscall("ioctl", action, ...)
			end,
			seek = function(_, whence, off)
				return syscall("seek", whence, off)
			end,
			-- no finalizer cuz no
			-- flags are not shared. TODO: consider setting fd flags on use
			flags = 0,
		}
	end
	local dev = devfsPathToDev(path)
	if dev then
		return devfsDevToFD(dev, mode)
	end
	return nil, errno.ENOENT
end

---@param req string
function Kocos._default_devfs(req, ...)
	if req == "FS-mount" then
		---@type Kocos.device
		local dev = ...
		if dev.type ~= "devfs" then return end
		return "devfs"
	end
	if req == "FS-mkdir" then
		return nil, Kocos.errno.EPERM
	end
	if req == "FS-touch" then
		return nil, Kocos.errno.EPERM
	end
	if req == "FS-openFile" then
		---@type unknown, string, string
		local _, path, mode = ...
		return devfsMakeFD(path, mode)
	end
	if req == "FS-listDir" then
		---@type unknown, string
		local _, path = ...
		if path == "" then
			local files = {"components", "null", "zero", "random", "hex", "stdin", "stderr", "stdout", "stdterm"}
			for f in pairs(computeDeviceFiles()) do
				table.insert(files, f)
			end
			return files
		end
		if path == "components" then
			local f = {}
			for addr in component.list() do
				table.insert(f, addr)
			end
			return f
		end
		return nil, path
	end
	if req == "FS-ftype" then
		---@type unknown, string
		local _, path = ...
		if path == "" then return fs.FTYPE_DIR end
		if path == "components" then return fs.FTYPE_DIR end
		if path == "null" then return fs.FTYPE_CHR end
		if path == "zero" then return fs.FTYPE_CHR end
		if path == "random" then return fs.FTYPE_CHR end
		if path == "hex" then return fs.FTYPE_CHR end
		if path == "stdin" then return fs.FTYPE_CHR end
		if path == "stderr" then return fs.FTYPE_CHR end
		if path == "stdout" then return fs.FTYPE_CHR end
		if path == "stdterm" then return fs.FTYPE_CHR end
		for f in pairs(computeDeviceFiles()) do
			if path == f then return fs.FTYPE_BLK end
		end
		if string.startswith(path, "components/") then
			for addr in component.list() do
				if path == "components/" .. addr then
					return fs.FTYPE_BLK
				end
			end
		end
		return fs.FTYPE_NONE
	end
	if req == "FS-exists" then
		---@type unknown, string
		local _, path = ...
		if path == "" then return true end
		if path == "components" then return true end
		if path == "null" then return true end
		if path == "zero" then return true end
		if path == "random" then return true end
		if path == "hex" then return true end
		if path == "stdin" then return true end
		if path == "stderr" then return true end
		if path == "stdout" then return true end
		if path == "stdterm" then return true end
		for f in pairs(computeDeviceFiles()) do
			if path == f then return true end
		end
		return false
	end
	if req == "FS-stat" then
		---@type unknown, string
		local _, path = ...
		local dev = devfsPathToDev(path)
		if dev then
			local ctype = component.type(dev)
			---@type integer
			local size = 0 -- TODO: make it correct
			local used = 0
			if ctype == "filesystem" then
				used = component.invoke(dev, "spaceUsed")
				size = component.invoke(dev, "spaceTotal")
			elseif ctype == "drive" or ctype == "partition" then
				size = component.invoke(dev, "getCapacity")
			end
			---@type Kocos.fs.stat
			return {
				deviceAddress = dev,
				deviceType = ctype,
				size = size,
				createdAt = 0,
				lastModified = 0,
				diskUsed = used,
				diskTotal = size,
				inode = math.random(0, 2^32-1),
				perms = 0,
			}
		end
		---@type Kocos.fs.stat
		return {
			deviceAddress = "devfs",
			deviceType = "devfs",
			size = 0,
			createdAt = 0,
			lastModified = 0,
			diskUsed = 0,
			diskTotal = 0,
			inode = math.random(0, 2^32-1),
			perms = 0,
		}
	end
end

Kocos.printk(Kocos.L_DEBUG, "devfs subsystem loaded")
Kocos.printk(Kocos.L_DEBUG, "adding devfs driver")

Kocos.addDriver(Kocos._default_devfs)

Kocos.printk(Kocos.L_DEBUG, "adding devfs component")

component.add {
	address = "devfs",
	type = "devfs",
	invoke = function() end,
	methods = {},
	slot = -1,
}
local process = {}

process.npid = 0

-- File descriptors / resources with special meanings
--- The standard input stream
process.STDIN = 0
--- The standard output stream
process.STDOUT = 1
--- The standard error stream
process.STDERR = 2
--- The standard terminal stream
process.STDTERM = 3

---@class Kocos.process.module
---@field data string
---@field src string

---@class Kocos.process.sharedLib
---@field modules table<string, Kocos.process.module>
---@field deps Kocos.process.sharedLib[]

---@class Kocos.resource
---@field refc integer
---@field opts integer
---@field file? Kocos.fs.FileDescriptor
---@field socket? Kocos.net.socket

---@alias Kocos.process.condition fun(): boolean

---@class Kocos.process
---@field state "running"|"dying"|"dead"|"finished"
---@field pid integer
---@field uid integer
---@field gid integer
---@field euid integer
---@field egid integer
---@field thread thread
---@field namespace _G
---@field args string[]
---@field blockUntil Kocos.process.condition[]
---@field env table<string, string>
---@field modules table<string, Kocos.process.module>
---@field deps Kocos.process.sharedLib[]
---@field driver? function
---@field fds table<integer, Kocos.resource>
---@field signals table<string, function>
---@field children table<integer, Kocos.process>
---@field parent? Kocos.process
---@field stopped boolean
---@field cwd string
---@field root string
---@field exe? string
---@field exitcode integer
---@field tracer? Kocos.process
---@field daemon? string
---@field ev_listener? function
---@field reEnterAs? Kocos.process
---@field executionDeadline? number
---@field proclocal table

---@type table<integer, Kocos.process>
process.allProcs = {}

---@class Kocos.process.daemon
---@field proc Kocos.process
---@field callback fun(cpid: integer, ...): ...

---@type table<string, Kocos.process.daemon>
process.daemons = {}

function process.nextPid()
	if Kocos.args.useExtremelySecurePidGeneration then
		local pid = math.random(1, 2^32-1)
		while process.allProcs[pid] do
			pid = math.random(1, 2^32-1)
		end
		return pid
	end
	local pid = process.npid
	process.npid = process.npid + 1
	return pid
end

---@param thread thread
---@param namespace _G
---@param uid integer
---@param gid integer
---@return Kocos.process
function process.create(thread, namespace, uid, gid)
	local pid = process.nextPid()

	---@type Kocos.process
	local proc = {
		pid = pid,
		uid = uid,
		gid = gid,
		euid = uid,
		egid = gid,
		thread = thread,
		namespace = namespace,
		args = {},
		env = {},
		modules = {},
		deps = {},
		fds = {},
		signals = {},
		children = {},
		stopped = false,
		state = "running",
		cwd = "/",
		root = "/",
		exitcode = 0,
		blockUntil = {},
		proclocal = {},
	}


	process.allProcs[pid] = proc

	return proc
end

---@param proc Kocos.process
---@param func function
---@return Kocos.process
function process.fork(proc, func)
	local forked = process.create(coroutine.create(func), proc.namespace, proc.uid, proc.gid)
	forked.euid = proc.euid
	forked.egid = proc.egid
	forked.args = table.copy(proc.args)
	forked.env = table.copy(proc.env)
	forked.blockUntil = table.copy(proc.blockUntil)
	-- no table.copy cuz they're immutable anyways
	forked.modules = proc.modules
	forked.deps = proc.deps
	-- driver is not copied over
	-- resources are retained
	for fd, res in pairs(proc.fds) do
		forked.fds[fd] = res
		res.refc = res.refc + 1
	end
	forked.stopped = proc.stopped
	forked.cwd = proc.cwd
	forked.root = proc.root
	forked.exitcode = proc.exitcode
	forked.tracer = proc.tracer
	forked.parent = proc
	forked.exe = proc.exe
	proc.children[forked.pid] = forked
	return forked
end

---@param proc Kocos.process
---@param parent Kocos.process
function process.isDecendantOf(proc, parent)
	while parent do
		if proc.parent == parent then return true end
		parent = parent.parent
	end
	return false
end

process.SIGABRT = "SIGABRT" -- process closed
process.SIGALRM = "SIGALRM" -- alarm
process.SIGTERM = "SIGTERM" -- terminate
process.SIGKILL = "SIGKILL" -- die
process.SIGUSR1 = "SIGUSR1" -- user specified
process.SIGUSR2 = "SIGUSR2" -- user specified 2
process.SIGCHLD = "SIGCHLD" -- child died
process.SIGINT = "SIGINT" -- interrupted
process.SIGPIPE = "SIGPIPE" -- the pipe is gone
process.SIGQUIT = "SIGQUIT" -- quit process
process.SIGSTOP = "SIGSTOP" -- stop process
process.SIGTSTP = "SIGTSTP" -- stop process too
process.SIGSYS = "SIGSYS" -- bad syscall
process.SIGWINCH = "SIGWINCH" -- window changed
process.SIGURG = "SIGURG" -- urgent stuff
process.SIGTRAP = "SIGTRAP" -- a trap
process.SIGCONT = "SIGCONT" -- continue
process.SIGSYSC = "SIGSYSC" -- when tracing, traced process did a system call
process.SIGSYSR = "SIGSYSR" -- when tracing, traced process did a system return
process.SIGPWR = "SIGPWR" -- shutdown or reboot

---@param proc Kocos.process
---@param signal string
function process.raise(proc, signal, ...)
	if not proc then return end
	if signal == process.SIGSTOP then
		proc.stopped = true
		if process.current == proc then coroutine.yield() end
		return
	end
	if signal == process.SIGKILL then
		process.terminate(proc)
		return
	end
	if signal == process.SIGCONT then
		proc.stopped = false
		return
	end
	if proc.stopped then return end -- nope
	if proc.signals[signal] then
		-- Handler!!!!!!!
		process.pcall(proc, proc.signals[signal], ...)
		-- no return to allow unmodifiable behavior
	else
		-- Default handlers
		if signal == process.SIGINT then
			process.terminate(proc)
			return
		end
		if signal == process.SIGPIPE then
			process.terminate(proc)
			return
		end
		if signal == process.SIGUSR1 then
			process.terminate(proc)
			return
		end
		if signal == process.SIGUSR2 then
			process.terminate(proc)
			return
		end
		if signal == process.SIGTRAP then
			local err = ...
			if type(err) == "string" then
				process.pcall(proc, syscall, "write", process.STDERR, err .. "\n")
			end
			process.terminate(proc)
			return
		end
		if signal == process.SIGTERM then
			process.terminate(proc)
			return
		end
	end

	-- Unmodifiable behavior
	if signal == process.SIGABRT then
		process.terminate(proc, 1)
		return
	end
end

---@param proc Kocos.process
---@param f fun(...): ...
---@param msgh fun(s: any): any
---@return boolean, ...
function process.xpcall(proc, f, msgh, ...)
	local oldCurProc = process.current
	process.current = proc
	-- OOM problem!!!!
	local t = {xpcall(f, msgh, ...)}
	process.current = oldCurProc
	return table.unpack(t)
end

---@param proc Kocos.process
---@param f fun(...): ...
---@return boolean, ...
function process.pcall(proc, f, ...)
	return process.xpcall(proc, f, tostring, ...)
end

---@param res Kocos.resource
function process.closeResource(res)
	res.refc = res.refc - 1
	if res.refc > 0 then return end

	if res.file then
		Kocos.fs.close(res.file)
	end
	if res.socket then
		Kocos.net.close(res.socket)
	end
end

---@param proc Kocos.process
---@param res Kocos.resource
function process.moveResource(proc, res)
	local fd = 0
	while proc.fds[fd] do fd = fd + 1 end
	proc.fds[fd] = res
	return fd
end

---@param proc Kocos.process
---@param exit? integer
function process.terminate(proc, exit)
	if proc.state ~= "running" then return end -- nice try, signal handler
	proc.state = "finished"
	proc.exitcode = exit or 1
	if proc == process.root then
		Kocos.panickf("KERNEL EXITED: %d", proc.exitcode)
		return
	end
	if proc == Kocos.process.init then
		Kocos.panickf("INIT EXITED: %d", proc.exitcode)
		return
	end
	if proc.parent then
		process.raise(proc.parent, process.SIGCHLD, proc.pid, proc.exitcode)
	end

	process.raise(proc, process.SIGABRT)

	if proc.driver then
		Kocos.removeDriver(proc.driver)
		proc.driver = nil
	end
	if proc.ev_listener then
		Kocos.event.forget(proc.ev_listener)
		proc.ev_listener = nil
	end

	if proc.daemon then
		-- daemon is gone
		process.daemons[proc.daemon] = nil
	end

	for _, res in pairs(proc.fds) do
		process.closeResource(res)
	end
	proc.fds={}

	if process.current == proc then
		coroutine.yield()
		return
	end
end

---@param proc Kocos.process
function process.close(proc)
	if proc.state == "dying" then return end -- nice try, signal handler
	if not process.allProcs[proc.pid] then return end -- somehow died twice???
	process.terminate(proc, 1)
	proc.state = "dying" -- to prevent bad shit

	---@type Kocos.process[]
	local allChildren = {}
	for _, child in pairs(proc.children) do table.insert(allChildren, child) end

	for _, child in ipairs(allChildren) do
		process.close(child)
	end

	if proc.parent then
		proc.parent.children[proc.pid] = nil
	end


	process.allProcs[proc.pid] = nil -- and he's gone
	proc.state = "dead"
end

---@param proc Kocos.process
---@param path string
function process.resolve(proc, path)
	if path:sub(1,1) == "/" then
		return Kocos.fs.join(proc.root, Kocos.fs.canonical(path))
	end
	return Kocos.fs.join(proc.root, proc.cwd, path)
end

---@param lib Kocos.process.sharedLib
---@param module string
---@param refs? table
---@return Kocos.process.module?
function process.libreadmod(lib, module, refs)
	refs = refs or {}
	-- in case of cyclical bullshit dependencies
	if refs[lib] then return end
	refs[lib] = true

	---@type Kocos.process.module?
	local mod = lib.modules[module]
	if mod then return mod end

	for _, dep in ipairs(lib.deps) do
		mod = process.libreadmod(dep, module, refs)
		if mod then return mod end
	end
end

---@param proc Kocos.process
---@param module string
---@return Kocos.process.module?
function process.readmod(proc, module)
	---@type Kocos.process.module?
	local mod = proc.modules[module]
	if mod then return mod end

	local refs = {}

	for _, dep in ipairs(proc.deps) do
		mod = process.libreadmod(dep, module, refs)
		if mod then return mod end
	end
end

---@class Kocos.process.image
---@field init function
---@field modules table<string, Kocos.process.module>
---@field deps string[]

---@param proc Kocos.process
---@param argv string[]
---@param env table<string, string>
---@param namespace _G
---@return boolean?, string?
function process.exec(proc, path, argv, env, namespace)
	local data = assert(readfile(path))
	for _, driver in ipairs(Kocos.drivers) do
		-- PROC-binfmt
		---@type Kocos.process.image?, string?
		local img, err2 = driver("PROC-binfmt", path, data, namespace)
		if err2 then
			-- actual error instead of being ignored
			return nil, err2
		end
		if img then
			-- if this is nil and err2 is also nil, means driver ignored it
			proc.exe = path
			proc.args = argv
			proc.env = env
			proc.namespace = namespace
			if proc.driver then
				Kocos.removeDriver(proc.driver)
				proc.driver = nil
			end
			proc.thread = coroutine.create(img.init)
			proc.modules = img.modules
			proc.deps = {} -- TODO: deps
			proc.signals = {} -- Signal handlers are ignored
			---@type integer[]
			local toClose = {}
			for fd, res in pairs(proc.fds) do
				-- TODO: check cloexec
				if (res.opts & Kocos.fs.O_CLOEXEC) ~= 0 then
					table.insert(toClose, fd)
				end
			end
			for _, fd in ipairs(toClose) do
				local res = proc.fds[fd]
				process.closeResource(res)
				proc.fds[fd] = nil
			end
			return true
		end
	end

	return nil, Kocos.errno.ENOEXEC
end

--- A function which can be used as the thread when no special
--- initialization needs to happen
function process.basicThread()
	require("_start", true)
end

---@param pid integer
function process.isDead(pid)
	return not process.allProcs[pid]
end

---@param proc Kocos.process
function process.isRunning(proc)
	return proc.state == "running"
end

---@param proc Kocos.process
function process.isBlocked(proc)
	while #proc.blockUntil > 0 do -- best feature in all of gaming
		if proc.blockUntil[1]() then
			-- holy shit we're free
			table.remove(proc.blockUntil, 1)
		else
			-- darn
			return true
		end
	end
	return false
end

---@param proc Kocos.process
---@param condition Kocos.process.condition
function process.blockUntil(proc, condition)
	table.insert(proc.blockUntil, condition)
	if proc.thread == coroutine.running() then
		coroutine.yield()
	elseif process.current.pid == proc.pid then
		-- it seems as if we are in a signal handler or callback on another process' thread
		-- this is like categorically awful situation, but we can still work with it
		while process.isBlocked(proc) do
			coroutine.yield()
		end
	end
end

---@param proc Kocos.process
function process.resume(proc)
	if proc.stopped then return end
	if process.isBlocked(proc) then return end
	if not process.isRunning(proc) then return end
	if coroutine.status(proc.thread) ~= "suspended" then return end
	local old = process.current
	process.current = proc.reEnterAs or proc
	proc.executionDeadline = computer.uptime() + 0.2
	local ok, err = coroutine.resume(proc.thread)
	-- TODO: compute how "nice" the value is
	proc.reEnterAs = process.current
	if proc.reEnterAs == proc then proc.reEnterAs = nil end
	process.current = old
	if not ok then
		Kocos.printkf(Kocos.L_ERROR, "Process %d crashed: %s", proc.pid, debug.traceback(proc.thread, err))
		process.raise(proc, process.SIGTRAP, debug.traceback(proc.thread, err))
		return
	end
	if not process.isRunning(proc) then return end
	if coroutine.status(proc.thread) == "dead" then
		local exit = err
		if type(exit) ~= "number" then exit = 0 end
		process.terminate(proc, exit)
	end
end

---@param proc Kocos.process
function process.isRoot(proc)
	return proc.uid == 0 or proc.euid == 0
end

function process.run()
	for _, proc in pairs(process.allProcs) do
		process.resume(proc)
	end
end

local rawload = load

-- safe version of load

---@param chunk function|string
---@param chunkname? string
---@param mode? "t"|"b"|"bt"
---@param env? table
---@return function?, string? error_message
function load(chunk, chunkname, mode, env)
	return rawload(chunk, chunkname, mode, env or process.current.namespace)
end

Kocos.printk(Kocos.L_DEBUG, "process system loaded")

Kocos.printk(Kocos.L_DEBUG, "creating kernel process")
process.current = process.create(coroutine.running(), _G, 0, 0)
process.root = process.current

Kocos.process = process
-- Requiring files!!!

local process = Kocos.process

---@param modname string
---@param uncached? boolean
---@param env? _G
---@return any, string
function require(modname, uncached, env)
	--- Prob very temporary, will need to be tweaked later
	env = env or process.current.namespace

	if env.package.loaded[modname] ~= nil and not uncached then
		return env.package.loaded[modname], ':loaded:'
	end

	local mod = process.readmod(process.current, modname)

	if mod then
		local f = assert(load(mod.data, "=" .. mod.src))
		local v = f(modname, uncached)
		if v == nil then v = true end
		if not uncached then env.package.loaded[modname] = v end
		return v, ':module:'
	end

	local luaCode = package.searchpath(modname, process.current.env["LUA_PATH"] or env.package.path)

	if luaCode then
		--if not uncached then env.package.loaded[modname] = true end
		local v = dofile(luaCode, modname, uncached)
		if v == nil then v = true end
		if not uncached then env.package.loaded[modname] = v end
		return v, luaCode
	end

	error("could not find module: " .. modname, 2)
end
-- Default executable formats

-- Header: --!lua (6 bytes)
-- Links in: the runtime
---@param ev "PROC-binfmt"
---@param path string
---@param data string
---@param namespace _G
---@return Kocos.process.image?, string?
function Kocos._default_luaExec(ev, path, data, namespace)
	if ev ~= "PROC-binfmt" then return end

	if data:sub(1, 6) ~= "--!lua" then return end

	local init, err = load(data, "=" .. path, nil, namespace)
	if not init then return nil, err end

	---@type Kocos.process.image
	return {
		init = function()
			require(Kocos.args.luaExecRT or "luart")
			local ok, exitcode = xpcall(init, debug.traceback, table.unpack(Kocos.process.current.args))
			if ok then
				if type(exitcode) == "number" then
					Kocos.process.terminate(Kocos.process.current, exitcode)
				else
					Kocos.process.terminate(Kocos.process.current, 0)
				end
			else
				Kocos.process.raise(Kocos.process.current, "SIGTRAP", exitcode)
			end
		end,
		deps = {Kocos.args.luaExecRTF},
		modules = {},
	}
end

-- Header: #! (2 bytes)
-- Links in: nothing
---@param ev "PROC-binfmt"
---@param path string
---@param data string
---@param namespace _G
---@return Kocos.process.image?, string?
function Kocos._default_shebang(ev, path, data, namespace)
	if ev ~= "PROC-binfmt" then return end
	if data:sub(1, 2) ~= "#!" then return end

	local nl = string.find(data, "\n")
	if nl then
		data = string.sub(data, 1, nl-1)
	end

	local cmd = data:sub(3)
	local args = string.split(cmd, " ")
	cmd = table.remove(args, 1)
	table.insert(args, path)
	return {
		init = function()
			local ok, err = syscall("exec", cmd, args)
			if ok then
				Kocos.process.terminate(Kocos.process.current, 0)
			else
				Kocos.process.raise(Kocos.process.current, "SIGTRAP", err)
			end
		end,
		deps = {},
		modules = {},
	}
end

Kocos.addDriver(Kocos._default_luaExec)
Kocos.addDriver(Kocos._default_shebang)
-- Networking layer
local net = {}
local errno = Kocos.errno

---@alias Kocos.net.socketstate "init"|"connecting"|"connected"|"listening"|"closed"

net.O_NONBLOCK = Kocos.fs.O_NONBLOCK

-- Events similar to FS

net.EV_CLOSED = Kocos.fs.EV_CLOSED
net.EV_DATAREADY = Kocos.fs.EV_DATAREADY
net.EV_WRITEDONE = Kocos.fs.EV_WRITEDONE
--- on success, it should contain 2 nilable strings: the connection ID and the error. If error is nil, the operation succeeded. The connection ID is meant to be returned by connect() and be *unique*
net.EV_CONNECTDONE = "connect-done"

---@class Kocos.net.addrinfo: table
--- An address of some kind depending on networking technology
---@field address any
---@field port integer

---@class Kocos.net.socket
---@field state Kocos.net.socketstate
---@field write? fun(self, data: string): boolean, string?
---@field read? fun(self, len: integer): string?, string?
---@field ioctl? fun(self, action: string, ...): ...
---@field close? fun(self)
---@field accept? fun(self): Kocos.net.socket?, string?
---@field listen? fun(self, addrinfo: Kocos.net.addrinfo): boolean, string?
---@field connect? fun(self, addrinfo: Kocos.net.addrinfo): string?, string?
---@field flags integer
---@field listener? function

---@param domain string
---@param protocol string
---@param host string
--- Either a name of an application-layer protocol or the port number
---@param service? string|integer
---@return Kocos.net.addrinfo?, string?
function net.getaddrinfo(domain, protocol, host, service)
	for _, driver in ipairs(Kocos.drivers) do
		local s, err = driver("NET-addrinfo", domain, protocol, host, service)
		if err then
			return nil, err
		end
		if s then
			return s
		end
	end
	return nil, errno.ENODRIVER
end

---@param domain string
---@param socktype string
---@param protocol? string
---@return Kocos.net.socket?, string?
function net.socket(domain, socktype, protocol)
	for _, driver in ipairs(Kocos.drivers) do
		local s, err = driver("NET-socket", domain, socktype, protocol)
		if err then
			return nil, err
		end
		if s then
			return s
		end
	end
	return nil, errno.ENODRIVER
end

---@param socket Kocos.net.socket
---@param data string
---@return boolean, string?
function net.write(socket, data)
	if socket.state ~= "connected" then
		return false, errno.EAGAIN
	end
	if socket.write then
		return socket:write(data)
	end
	return false, errno.EBADF
end

---@param socket Kocos.net.socket
---@param len integer
---@return string?, string?
function net.read(socket, len)
	if socket.state ~= "connected" then
		return nil, errno.EAGAIN
	end
	if socket.read then
		return socket:read(len)
	end
	return nil, errno.EBADF
end

---@param socket Kocos.net.socket
---@param ev string
function net.notify(socket, ev, ...)
	if socket.listener then
		socket:listener(ev, ...)
	end
end

---@param socket Kocos.net.socket
---@return string?, string?
function net.close(socket)
	net.notify(socket, net.EV_CLOSED)
	socket.state = "closed"
	if socket.close then
		return socket:close()
	end
end

---@param socket Kocos.net.socket
---@param action string
function net.ioctl(socket, action, ...)
	if socket.ioctl then
		return socket:ioctl(action, ...)
	end
	return nil, errno.EBADF
end

---@param socket Kocos.net.socket
---@return Kocos.net.socket?, string?
function net.accept(socket)
	if socket.state ~= "listening" then
		return nil, errno.EBADF
	end
	if socket.accept then
		return socket:accept()
	end
	return nil, errno.EBADF
end

---@param socket Kocos.net.socket
---@param addrinfo Kocos.net.addrinfo
---@return string?, string?
function net.connect(socket, addrinfo)
	if socket.state ~= "init" then
		return nil, errno.EISCONN
	end
	if socket.connect then
		return socket:connect(addrinfo)
	end
	return nil, errno.EBADF
end

---@param socket Kocos.net.socket
---@param addrinfo Kocos.net.addrinfo
---@return boolean, string?
function net.listen(socket, addrinfo)
	if socket.state == "init" then
		return false, errno.EISCONN
	end
	if socket.listen then
		return socket:listen(addrinfo)
	end
	return false, errno.EBADF
end

Kocos.net = net
Kocos.printk(Kocos.L_DEBUG, "network subsystem loaded")
local process = Kocos.process
local errno = Kocos.errno

---@class Kocos.syscalls
local syscalls = {}

---@param path string
---@param mode "r"|"a"|"w"
function syscalls.open(path, mode)
	-- TODO: validate permissions

	if type(path) ~= "string" or type(mode) ~= "string" then
		return nil, errno.EINVAL
	end

	if mode ~= "r" and mode ~= "w" and mode ~= "a" then
		return nil, errno.EINVAL
	end

	path = process.resolve(process.current, path)

	local file, err = Kocos.fs.open(path, mode)
	if not file then return nil, err end

	---@type Kocos.resource
	local res = {refc = 1, opts = 0, file = file}

	return process.moveResource(process.current, res)
end

---@param path string
---@param perms integer
---@return boolean?, string?
function syscalls.touch(path, perms)
	if type(path) ~= "string" then
		return nil, errno.EINVAL
	end
	if type(perms) ~= "number" then
		return nil, errno.EINVAL
	end
	perms = math.floor(perms)
	path = process.resolve(process.current, path)
	return Kocos.fs.touch(path, perms, process.current.uid, process.current.gid)
end

---@param path string
---@param perms integer
---@return boolean?, string?
function syscalls.mkdir(path, perms)
	if type(path) ~= "string" then
		return nil, errno.EINVAL
	end
	if type(perms) ~= "number" then
		return nil, errno.EINVAL
	end
	perms = math.floor(perms)
	path = process.resolve(process.current, path)
	return Kocos.fs.mkdir(path, perms, process.current.uid, process.current.gid)
end

---@param path string
---@return boolean?, string?
function syscalls.remove(path)
	if type(path) ~= "string" then
		return nil, errno.EINVAL
	end
	path = process.resolve(process.current, path)
	return Kocos.fs.remove(path)
end

---@param path string
---@param addr string
---@return boolean?, string?
function syscalls.mountDev(path, addr)
	if type(path) ~= "string" then
		return nil, errno.EINVAL
	end
	if type(addr) ~= "string" then
		return nil, errno.EINVAL
	end
	path = process.resolve(process.current, path)
	if Kocos.fs.ftype(path) ~= Kocos.fs.FTYPE_DIR then
		return nil, errno.ENOTDIR
	end
	local parentmnt, p = Kocos.fs.resolve(path, true)
	local dev = component.proxy(addr)
	if not dev then return nil, errno.ENODEV end
	local mnt = Kocos.fs.mount(dev)
	if not mnt then
		return nil, errno.ENODRIVER
	end
	parentmnt.submounts[p] = mnt
	return true
end

---@param path string
---@return boolean, string?
function syscalls.unmount(path)
	if type(path) ~= "string" then
		return false, errno.EINVAL
	end
	path = process.resolve(process.current, path)
	local parentmnt, p = Kocos.fs.resolve(path, true)
	local mnt = parentmnt.submounts[p]
	if not mnt then
		return false, errno.EISDIR
	end
	Kocos.fs.unmount(mnt)
	parentmnt.submounts[p] = nil
	return true
end

--- Returns a map of paths obtained from depth-first search to device addresses
function syscalls.getMounts()
	---@type table<string, string>
	local t = {}

	---@type string[]
	local queue = {"/"}

	while true do
		local p = table.remove(queue, 1)
		if not p then break end

		local dev = Kocos.fs.resolve(p)
		if not t[dev.dev.address] then
			t[dev.dev.address] = p
			for mp in pairs(dev.submounts) do
				table.insert(queue, Kocos.fs.join(p, mp))
			end
		end
	end

	return t
end

---@param fd integer
---@param length integer
---@return string?, string?
function syscalls.read(fd, length)
	if type(fd) ~= "number" then
		return nil, errno.EINVAL
	end
	if type(length) ~= "number" then
		return nil, errno.EINVAL
	end
	local proc = process.current
	local f = proc.fds[fd]
	if f then
		if f.file then
			if f.file.read then
				return f.file:read(length)
			end
			return nil, errno.EBADF
		end
		if f.socket then
			return Kocos.net.read(f.socket, length)
		end
		-- TODO: other resource types
	end
	return nil, errno.EBADF
end

---@param fd integer
---@param data string
---@return boolean?, string?
function syscalls.write(fd, data)
	if type(fd) ~= "number" then
		return nil, errno.EINVAL
	end
	if type(data) ~= "string" then
		return nil, errno.EINVAL
	end
	local proc = process.current
	local f = proc.fds[fd]
	if f then
		if f.file then
			return Kocos.fs.write(f.file, data)
		end
		if f.socket then
			return Kocos.net.write(f.socket, data)
		end
		-- TODO: other resource types
	end
	return nil, errno.EBADF
end

---@param fd integer
---@return boolean?, string?
function syscalls.close(fd)
	if type(fd) ~= "number" then
		return nil, errno.EINVAL
	end
	local proc = process.current
	local f = proc.fds[fd]
	if not f then return nil, errno.EBADF end
	proc.fds[fd] = nil
	process.closeResource(f)
	return true
end

---@param fd integer
---@param whence seekwhence
---@param off integer
---@return integer?, string?
function syscalls.seek(fd, whence, off)
	if type(fd) ~= "number" then
		return nil, errno.EINVAL
	end
	local proc = process.current
	local f = proc.fds[fd]
	if not f then return nil, errno.EBADF end
	if f.file then
		return Kocos.fs.seek(f.file, whence, off)
	end
	return nil, errno.EBADF
end

---@param fd integer
---@param action string
---@return ...
function syscalls.ioctl(fd, action, ...)
	if type(fd) ~= "number" then
		return nil, errno.EINVAL
	end
	local proc = process.current
	local f = proc.fds[fd]
	if not f then return nil, errno.EBADF end
	if f.file then
		return Kocos.fs.ioctl(f.file, action, ...)
	end
	if f.socket then
		return Kocos.net.ioctl(f.socket, action, ...)
	end
	return nil, errno.EBADF
end

---@param domain string
---@param protocol string
---@param host string
--- Either a name of an application-layer protocol or the port number
---@param service? string|integer
---@return Kocos.net.addrinfo?, string?
function syscalls.getaddrinfo(domain, protocol, host, service)
	if type(domain) ~= "string" then
		return nil, errno.EINVAL
	end
	if type(protocol) ~= "string" then
		return nil, errno.EINVAL
	end
	if type(host) ~= "string" then
		return nil, errno.EINVAL
	end
	if type(service) ~= "string" and type(service) ~= "number" and type(service) ~= "nil" then
		return nil, errno.EINVAL
	end
	return Kocos.net.getaddrinfo(domain, protocol, host, service)
end

---@param domain string
---@param socktype string
---@param protocol? string
---@return integer?, string?
function syscalls.socket(domain, socktype, protocol)
	if type(domain) ~= "string" then
		return nil, errno.EINVAL
	end
	if type(socktype) ~= "string" then
		return nil, errno.EINVAL
	end
	if type(protocol) ~= "string" and type(protocol) ~= "nil" then
		return nil, errno.EINVAL
	end
	local sock, err = Kocos.net.socket(domain, socktype, protocol)
	if not sock then return nil, err end

	return Kocos.process.moveResource(Kocos.process.current, {
		refc = 1,
		opts = 0,
		socket = sock,
	})
end

---@param fd integer
function syscalls.accept(fd)
	local res = process.current.fds[fd]
	if not res then return nil, errno.EBADF end
	local s = res.socket
	if not s then return nil, errno.ENOTSOCK end

	local client, err = Kocos.net.accept(s)
	if not client then return nil, err end

	return Kocos.process.moveResource(Kocos.process.current, {
		refc = 1,
		opts = 0,
		socket = client,
	})
end

---@param fd integer
---@param addrinfo Kocos.net.addrinfo
function syscalls.connect(fd, addrinfo)
	-- prevents some security issues
	setmetatable(addrinfo, nil)

	local res = process.current.fds[fd]
	if not res then return nil, errno.EBADF end
	local s = res.socket
	if not s then return nil, errno.ENOTSOCK end

	return Kocos.net.connect(s, addrinfo)
end

---@param fd integer
---@param addrinfo Kocos.net.addrinfo
function syscalls.listen(fd, addrinfo)
	-- prevents some security issues
	setmetatable(addrinfo, nil)

	local res = process.current.fds[fd]
	if not res then return nil, errno.EBADF end
	local s = res.socket
	if not s then return nil, errno.ENOTSOCK end

	return Kocos.net.listen(s, addrinfo)
end

---@return integer?, string?
function syscalls.dup(fd)
	local res = process.current.fds[fd]
	if not res then return nil, errno.EBADF end
	local f = process.moveResource(process.current, res)
	res.refc = res.refc + 1
	return f
end

---@return boolean, string?
function syscalls.dup2(fd, newFd)
	local res = process.current.fds[fd]
	if not res then return false, errno.EBADF end
	if process.current.fds[newFd] then return false, errno.EEXIST end
	process.current.fds[newFd] = res
	res.refc = res.refc + 1
	return true
end

function syscalls.fcntl(fd, action, ...)
	if type(fd) ~= "number" then
		return nil, errno.EINVAL
	end
	local proc = process.current
	local f = proc.fds[fd]
	if not f then return nil, errno.EBADF end
	if action == Kocos.fs.F_SETCB then
		---@type function?
		local listener = ...
		if type(listener) ~= "function" and type(listener) ~= "nil" then
			return nil, errno.EINVAL
		end
		if f.file then
			return Kocos.fs.setlistener(f.file, listener)
		end
		return nil, errno.EBADF
	end
	if action == Kocos.fs.F_GETFL then
		return f.opts
	end
	if action == Kocos.fs.F_SETFL then
		---@type integer
		local flags = ...
		if type(flags) ~= "number" then
			return nil, errno.EINVAL
		end
		flags = math.abs(math.floor(flags))
		f.opts = flags
		if f.file then
			f.file.flags = flags
		end
		if f.socket then
			f.socket.flags = flags
		end
		return true
	end
	if action == Kocos.fs.F_NOTIF then
		---@type string
		local ev = ...
		if type(ev) ~= "string" then
			return nil, errno.EINVAL
		end
		if f.file then
			Kocos.fs.notify(f.file, ...)
			return true
		end
		if f.socket then
			Kocos.net.notify(f.socket, ...)
			return true
		end
		return nil, errno.EBADF
	end
	return nil, errno.EINVAL
end

---@param path string
---@return string[]?, string?
function syscalls.list(path)
	path = process.resolve(process.current, path)
	return Kocos.fs.list(path)
end

---@param path string
---@return Kocos.fs.stat?, string?
function syscalls.stat(path)
	path = process.resolve(process.current, path)
	return Kocos.fs.stat(path)
end

---@param path string
---@return Kocos.fs.ftype?, string?
function syscalls.ftype(path)
	path = process.resolve(process.current, path)
	return Kocos.fs.ftype(path)
end

---@param path string
---@return boolean?, string?
function syscalls.exists(path)
	path = process.resolve(process.current, path)

	return Kocos.fs.exists(path, true)
end

---@param path string
---@return string
function syscalls.absolutepath(path)
	return process.resolve(process.current, path)
end

---@param path string
---@return string
function syscalls.canonical(path)
	return Kocos.fs.canonical(path)
end


---@param s string
---@vararg string
---@return string
function syscalls.join(s, ...)
	return Kocos.fs.join(process.resolve(process.current, s), ...)
end

---@param path string
---@return boolean?, string?
function syscalls.validlink(path)
	path = process.resolve(process.current, path)

	return Kocos.fs.exists(path)
end

---@param f function
---@return integer Returns pid of new process
function syscalls.fork(f)
	local child = process.fork(process.current, f)
	process.resume(child) -- give child a chance to shine
	return child.pid
end

function syscalls.environ()
	-- mutating it is fine
	return process.current.env
end

function syscalls.argv()
	-- mutating it is technically fine but please don't
	return process.current.args
end

function syscalls.sleep(time)
	if type(time) ~= "number" then
		return nil, errno.EINVAL
	end

	local deadline = computer.uptime() + time
	process.blockUntil(process.current, function()
		return computer.uptime() >= deadline
	end)
	return true
end

---@return number
function syscalls.uptime()
	return computer.uptime()
end

function syscalls.sync()
	Kocos.fs.sync()
	return true
end

---@param path string
---@param argv string[]?
---@param env table<string, string>?
---@param namespace _G?
---@return boolean, string?
function syscalls.exec(path, argv, env, namespace)
	if type(path) ~= "string" then
		return false, errno.EINVAL
	end

	local cur = process.current

	argv = argv or {[0] = path}
	argv[0] = argv[0] or path
	env = env or table.copy(cur.env)
	namespace = namespace or cur.namespace

	path = process.resolve(cur, path)

	-- TODO: check read + exec perms

	local ok, err = process.exec(cur, path, argv, env, namespace)
	if not ok then return false, err end

	-- TODO: consider some way to resume it instantly
	--process.resume(cur) -- deadlocks?
	coroutine.yield() -- and, its gone.
	return true
end

---@param module string
---@return string?, string?
function syscalls.readmod(module)
	if type(module) ~= "string" then return nil, errno.EINVAL end

	local mod = process.readmod(process.current, module)
	if mod then
		return mod.data, mod.src
	end
	return nil, errno.ENOENT
end

---@param filter? string
---@param exact? boolean
function syscalls.clist(filter, exact)
	---@type table<string, string>
	local t = {}
	for addr, type in component.list(filter, exact) do
		t[addr] = type
	end
	local k
	setmetatable(t, {
		__call = function()
			k = next(t, k)
			return k, t[k]
		end,
	})
	return t
end

---@param shortform string
---@param filter? string
---@param exact? boolean
---@return string?, string?
function syscalls.caddress(shortform, filter, exact)
	if type(shortform) ~= "string" then
		return nil, errno.EINVAL
	end
	local l, err = syscalls.clist(filter, exact)
	if err then return nil, err end
	for addr in l do
		if string.startswith(addr, shortform) then
			return addr
		end
	end
	return nil, errno.ENODEV
end

---@param dev Kocos.vdevice
function syscalls.cadd(dev)
	if not process.isRoot(process.current) then
		return false, errno.EPERM
	end
	if component.type(dev.address) then
		return false, errno.EADDRINUSE
	end
	component.add(dev)
	return true
end

---@param address string
function syscalls.cremove(address)
	if not process.isRoot(process.current) then
		return false, errno.EPERM
	end
	if not component.isVirtual(address) then
		return false, errno.ENODEV
	end
	component.remove(address)
	return true
end

---@param image Kocos.ramfs.node
---@param label string?
---@param readonly boolean
---@param addr string?
---@return string?, string?
function syscalls.cramfs(image, label, readonly, addr)
	if not process.isRoot(process.current) then
		return nil, errno.EPERM
	end
	return Kocos.addRamfsComponent({
		label = label,
		readonly = readonly,
		fds = {},
		image = image,
	}, addr)
end

function syscalls.cmethods(addr)
	return component.methods(addr)
end

function syscalls.cinvoke(addr, method, ...)
	return component.invoke(addr, method, ...)
end

---@return Kocos.device?
function syscalls.cproxy(addr)
	return component.proxy(addr)
end

---@return Kocos.device?
function syscalls.cprimary(type)
	return component.getPrimary(type)
end

function syscalls.cfields(addr)
	return component.fields(addr)
end

function syscalls.cdoc(addr, method)
	return component.doc(addr, method)
end

function syscalls.cslot(addr)
	return component.slot(addr)
end

function syscalls.ctype(addr)
	return component.type(addr)
end

---@param pid integer
---@return integer
function syscalls.waitpid(pid)
	local proc = process.allProcs[pid]
	if not proc then return 0 end
	process.resume(proc)
	-- theoretically a signal can fuck us up however we do not care
	process.blockUntil(process.current, function()
		return not process.isRunning(proc)
	end)
	process.close(proc)
	return proc.exitcode
end

---@param pid integer
---@param condition Kocos.process.condition
---@return boolean, string?
function syscalls.blockUntil(pid, condition)
	local p = process.allProcs[pid]
	if not p then return false, errno.ESRCH end
	if type(condition) ~= "function" then return false, errno.EINVAL end

	-- optimization
	if condition() then return true end

	local cur = process.current
	if cur.uid ~= 0 and not process.isDecendantOf(p, cur) then
		return nil, errno.EPERM
	end

	process.blockUntil(p, function()
		local ok, s = process.pcall(cur, condition)
		if not ok then return false end
		return s
	end)
	return true
end

---@param dir string
---@return string?, string?
function syscalls.chdir(dir)
	if type(dir) ~= "string" then
		return nil, errno.EINVAL
	end
	if dir == "." then return process.current.cwd end
	dir = process.resolve(process.current, dir)
	dir = Kocos.fs.fromRoot(dir, process.current.root)
	process.current.cwd = dir
	return dir
end

---@param dir string
---@return string?, string?
function syscalls.chroot(dir)
	if type(dir) ~= "string" then
		return nil, errno.EINVAL
	end
	if dir == "." then return process.current.cwd end
	dir = process.resolve(process.current, dir)
	process.current.root = dir
	return dir
end

---@class Kocos.sysinfoResult
---@field kernel string
---@field os string
---@field bootAddress string
---@field rootAddress string
---@field tmpAddress string
---@field hostname string
---@field memtotal integer
---@field memfree integer
---@field kernelPID integer
---@field initPID integer
---@field energy number
---@field maxEnergy number

function syscalls.sysinfo()
	---@type Kocos.sysinfoResult
	return {
		kernel = _KVERSION,
		os = _OSVERSION,
		bootAddress = computer.getBootAddress(),
		rootAddress = Kocos.fs.root.dev.address,
		tmpAddress = computer.tmpAddress(),
		memfree = computer.freeMemory(),
		memtotal = computer.totalMemory(),
		hostname = Kocos.hostname,
		kernelPID = process.root.pid,
		initPID = process.init.pid,
		energy = computer.energy(),
		maxEnergy = computer.maxEnergy(),
	}
end


---@param addr? string
function syscalls.chboot(addr)
	if addr then
		if type(addr) ~= "string" then
			return nil, errno.EINVAL
		end
		if process.current.euid ~= 0 then
			return nil, errno.EPERM
		end
		computer.setBootAddress(addr)
	end
	return computer.getBootAddress()
end

---@param addr string
---@return boolean, string?
function syscalls.chsysroot(addr)
	if type(addr) ~= "string" then
		return false, errno.EINVAL
	end
	if process.current.euid ~= 0 then
		return false, errno.EPERM
	end
	local proxy = component.proxy(addr)
	if not proxy then return false, errno.ENODEV end
	local newRoot = Kocos.fs.mount(proxy)
	if not newRoot then return false, errno.ENODRIVER end
	local oldRoot = Kocos.fs.root
	Kocos.fs.root = newRoot
	if oldRoot then Kocos.fs.unmount(oldRoot) end
	return true
end

---@param hostname string?
---@return string?, string?
function syscalls.hostname(hostname)
	if hostname then
		if process.current.euid ~= 0 then
			return nil, errno.EACCESS
		end
		Kocos.hostname = hostname
	end
	return Kocos.hostname
end

---@return string[]
function syscalls.syscalls()
	local s = {}
	for k in pairs(syscalls) do table.insert(s, k) end
	return s
end

---@param daemon string
---@param callback fun(cpid: integer, ...): ...
function syscalls.registerDaemon(daemon, callback)
	local d = process.daemons[daemon]
	if d then return nil, errno.EADDRINUSE end
	if process.current.daemon then
		return nil, errno.EALREADY
	end
	process.daemons[daemon] = {
		proc = process.current,
		callback = callback,
	}
	process.current.daemon = daemon
	return true
end

---@param daemon string
---@return integer?, string?
function syscalls.getDaemonPid(daemon)
	local d = process.daemons[daemon]
	if not d then return nil, errno.ESRCH end
	return d.proc.pid
end

---@return string[]
function syscalls.listDaemons()
	local daemons = {}
	for addr in pairs(process.daemons) do
		table.insert(daemons, addr)
	end
	return daemons
end

---@param daemon string
---@return ...
function syscalls.invokeDaemon(daemon, ...)
	local d = process.daemons[daemon]
	if not d then return nil, errno.ESRCH end
	local t = {process.pcall(d.proc, d.callback, process.current.pid, ...)}
	if t[1] then
		return table.unpack(t, 2)
	end
	return nil, table.unpack(t, 2)
end

---@return integer[]
function syscalls.getprocs()
	local pids = {}
	for pid in pairs(process.allProcs) do
		table.insert(pids, pid)
	end
	return pids
end

function syscalls.getpid()
	return process.current.pid
end

function syscalls.getuid()
	return process.current.uid
end

function syscalls.getgid()
	return process.current.gid
end

function syscalls.geteuid()
	return process.current.euid
end

function syscalls.getegid()
	return process.current.egid
end

---@param uid integer
---@param pid? integer
---@return boolean, string?
function syscalls.setuid(uid, pid)
	local cur = process.current
	local target = process.allProcs[pid or cur.pid]
	if not target then return false, errno.ESRCH end
	if not process.isDecendantOf(target, cur) then
		return false, errno.EPERM
	end
	if uid == 0 and not process.isRoot(cur) then
		return false, errno.EPERM
	end
	target.uid = uid
	return true
end

--- Set the tracer to process at [pid]
---@param pid integer
---@return boolean, string?
function syscalls.strace(pid)
	local p = process.allProcs[pid]
	if not p then return false, errno.ESRCH end
	if not process.isDecendantOf(process.current, p) then
		return false, errno.EPERM
	end
	process.current.tracer = p
	return true
end

---@param gid integer
---@param pid? integer
---@return boolean, string?
function syscalls.setgid(gid, pid)
	local cur = process.current
	local target = process.allProcs[pid or cur.pid]
	if not target then return false, errno.ESRCH end
	if not process.isDecendantOf(target, cur) then
		return false, errno.EPERM
	end
	if gid == 0 and not process.isRoot(cur) then
		return false, errno.EPERM
	end
	target.gid = gid
	return true
end

---@param uid integer
---@param pid? integer
---@return boolean, string?
function syscalls.seteuid(uid, pid)
	local cur = process.current
	local target = process.allProcs[pid or cur.pid]
	if not target then return false, errno.ESRCH end
	if not process.isDecendantOf(target, cur) and not process.isRoot(cur) then
		return false, errno.EPERM
	end
	if uid == 0 and not process.isRoot(cur) then
		target.euid = target.uid
		return true
	end
	target.euid = uid
	return true
end

---@param gid integer
---@param pid? integer
---@return boolean, string?
function syscalls.setegid(gid, pid)
	local cur = process.current
	local target = process.allProcs[pid or cur.pid]
	if not target then return false, errno.ESRCH end
	if not process.isDecendantOf(target, cur) and not process.isRoot(cur) then
		return false, errno.EPERM
	end
	if gid == 0 and not process.isRoot(cur) then
		target.egid = target.gid
		return true
	end
	target.egid = gid
	return true
end

---@class Kocos.process.info
---@field argv? string[]
---@field environ? table<string, string>
---@field uid? integer
---@field euid? integer
---@field gid? integer
---@field egid? integer
---@field parent? integer
---@field driver? boolean
---@field daemon? string
---@field tracer? integer
---@field exitcode? integer
---@field cwd? string
---@field exe? string
---@field namespace? _G
---@field children? integer[]
---@field signals? string[]

---@param pid integer
---@vararg "args"|"env"|"uid"|"gid"|"parent"|"tree"|"state"|"namespace"|"signals"
---@return Kocos.process.info?, string?
function syscalls.getprocinfo(pid, ...)
	local proc = process.allProcs[pid]
	if not proc then return nil, errno.ESRCH end
	local isTrusted = process.current.euid == 0 or process.isDecendantOf(proc, process.current)
	---@type Kocos.process.info
	local info = {}
	local vlen = select("#", ...)
	for i=1, vlen do
		local v = select(i, ...)
		if v == "args" then
			info.argv = table.copy(proc.args)
		elseif v == "env" then
			info.environ = table.copy(proc.env)
		elseif v == "uid" then
			info.uid = proc.uid
			info.euid = proc.euid
		elseif v == "gid" then
			info.gid = proc.gid
			info.egid = proc.egid
		elseif v == "parent" then
			if proc.parent then info.parent = proc.parent.pid end
		elseif v == "tree" then
			if proc.parent then info.parent = proc.parent.pid end
			info.children = {}
			for cpid in pairs(proc.children) do
				table.insert(info.children, cpid)
			end
		elseif v == "state" then
			if proc.parent then info.parent = proc.parent.pid end
			if proc.tracer then info.tracer = proc.tracer.pid end
			info.driver = not not proc.driver
			info.exitcode = proc.exitcode
			info.exe = proc.exe
			info.cwd = proc.cwd
		elseif v == "namespace" then
			if isTrusted then info.namespace = proc.namespace end
		elseif v == "signals" then
			info.signals = {}
			for sig in pairs(proc.signals) do
				table.insert(info.signals, sig)
			end
		end
	end
	return info
end

function syscalls.proclocal()
	return process.current.proclocal
end

---@param pid integer
---@param signal string
function syscalls.kill(pid, signal, ...)
	local cur = process.current
	local target = process.allProcs[pid]
	if not target then return nil, errno.ESRCH end
	-- signals that are just not sendable even by root,
	-- cuz their meaning would be violated
	if signal == "SIGTRAP" then return nil, errno.EPERM end
	if signal == "SIGCHLD" then return nil, errno.EPERM end
	if signal == "SIGABRT" then return nil, errno.EPERM end
	local allowed = process.isRoot(cur) or cur.uid == target.uid or cur.euid == target.euid or cur.euid == target.uid
	if not allowed then
		return nil, errno.EPERM
	end
	process.raise(target, signal, ...)
	return true
end

---@param sig string
---@param f function
function syscalls.signal(sig, f)
	process.current.signals[sig] = f
	return true
end

function syscalls.abort()
	process.raise(process.current, process.SIGABRT)
end

---@param code? integer
function syscalls.exit(code)
	code = code or 0
	process.terminate(process.current, code)
	return 0
end

---@param driver? function
---@return boolean?, string?
function syscalls.mkdriver(driver)
	local cur = process.current
	if cur.euid ~= 0 then
		return nil, errno.EPERM
	end
	if cur.driver then
		Kocos.removeDriver(driver)
	end
	cur.driver = driver
	Kocos.addDriver(driver)
	return true
end

---@param listener? function
---@return boolean?, string?
function syscalls.mklistener(listener)
	local cur = process.current
	if cur.euid ~= 0 then
		return nil, errno.EPERM
	end
	if cur.ev_listener then
		Kocos.event.forget(cur.ev_listener)
	end
	cur.ev_listener = listener
	Kocos.event.listen(listener)
	return true
end

function syscalls.errnos()
	return table.copy(Kocos.errno)
end

---@param pid integer
---@return boolean, string?
function syscalls.resume(pid)
	local proc = process.allProcs[pid]
	if not proc then return false, errno.ESRCH end
	process.resume(proc)
	return true
end

Kocos.syscalls = syscalls

---@diagnostic disable: lowercase-global
---@param sysname string
---@return ...
function syscall(sysname, ...)
	local cur = process.current

	if cur.executionDeadline and computer.uptime() > cur.executionDeadline then
		coroutine.yield()
	end

	if process.isDead(cur.pid) then return nil, errno.ECHILD end
	if not syscalls[sysname] then return nil, errno.ENOSYS end
	if cur.tracer then
		-- inform the tracer
		process.raise(cur.tracer, process.SIGSYSC, cur.pid, sysname, {...})
	end
	local t = {pcall(syscalls[sysname], ...)}

	if cur.tracer then
		-- inform the tracer
		local ret = t[1] and {table.unpack(t, 2)} or {nil, t[2]}
		process.raise(cur.tracer, process.SIGSYSR, cur.pid, sysname, {...}, ret)
	end

	if not process.isRunning(process.current) then
		coroutine.yield() -- we're dead
	end

	if t[1] then
		return table.unpack(t, 2)
	end
	return nil, t[2]
end
Kocos.printkf(Kocos.L_INFO, "Booting %s...", _KVERSION)

Kocos.printkf(Kocos.L_DEBUG, "Detecting hardware...")
for addr, type in component.list() do
	Kocos.printkf(Kocos.L_DEBUG, "%s %s", addr, type)
end

-- At this point we're supposed to mount the bootfs, either ramfs image or actual root
Kocos.printk(Kocos.L_INFO, "mounting boot filesystem at /")

local rootDev

if Kocos.args.ramfs then
	rootDev = Kocos.addRamfsComponent(Kocos.args.ramfs, "ramfs")
	Kocos.printk(Kocos.L_DEBUG, "mounting as ramfs tmp root")
else
	rootDev = Kocos.args.root or computer.getBootAddress()
	Kocos.printk(Kocos.L_DEBUG, "mounting as managedfs true root")
end

do
	assert(rootDev, "missing root device")
	assert(Kocos.syscalls.chsysroot(rootDev))
end

local freeMem = computer.freeMemory()
local totalMem = computer.totalMemory()

Kocos.printkf(Kocos.L_INFO, "Free Memory: %s / %s", string.memformat(freeMem), string.memformat(totalMem))

---@alias Kocos.shutdownType "halt"|"poweroff"|"reboot"
---@type Kocos.shutdownType?
Kocos.shutdown = nil

if freeMem < 64*1024 then
	Kocos.printkf(Kocos.L_WARN, "FREE MEMORY IS BELOW 64KiB!!!")
end

local function tick()
	if Kocos.shutdown then
		Kocos.printkf(Kocos.L_INFO, "Attempting %s", Kocos.shutdown)
		Kocos.poweroff(Kocos.shutdown == "reboot")
		return
	end
	Kocos.process.run()
	local interval = Kocos.args.pollInterval or 0
	local percent = computer.energy() / computer.maxEnergy()
	if percent < 0.5 then
		interval = Kocos.args.midBatteryPollInterval or 0.1 -- idle longer to save battery
	end
	if percent < 0.1 then
		interval = Kocos.args.midBatteryPollInterval or 0.2 -- idle way longer to save battery
	end
	Kocos.event.pull(interval)
end

local initPaths = {
	-- init process
	"/sbin/init",
	"/bin/init",
	-- login???
	"/sbin/login",
	"/bin/login",
	-- shell???
	"/sbin/sh",
	"/bin/sh",
}

-- classic fork() exec()
local initProc = Kocos.process.fork(Kocos.process.root, function()
	Kocos.process.init.executionDeadline = math.huge
	for _, path in ipairs(initPaths) do
		if Kocos.syscalls.exists(path) then
			Kocos.printkf(Kocos.L_INFO, "Running %s...", path)
			assert(Kocos.syscalls.exec(path))
		end
	end
	Kocos.panickf("COULD NOT FIND INIT PROGRAM!\nSearched: %s\n", table.concat(initPaths, "\n"))
end)
Kocos.process.init = initProc

initProc.fds[1] = {
	refc = 4,
	opts = 0,
	file = Kocos.fs.fd_from_rwf(function(_, len)
		return Kocos.scr_read(len)
	end, function(_, data)
		local bufSize = 1024
		if #data <= bufSize then
			Kocos.scr_write(data)
			return true
		end
		-- makes it so you can't write 1MB and freeze the system
		for i=1,#data,bufSize do
			local buf = data:sub(i, i+bufSize - 1)
			Kocos.scr_write(buf)
			coroutine.yield()
		end
		return true
	end, nil, function(_, ...) return Kocos.scr_ioctl(...) end),
}

initProc.fds[0] = initProc.fds[1]
initProc.fds[2] = initProc.fds[1]
initProc.fds[3] = initProc.fds[1]

Kocos.process.resume(initProc)

local function justDie()
	pcall(computer.pullSignal, 2)
	computer.shutdown(true)
end

while true do
	local ok, err = xpcall(tick, debug.traceback)
	if not ok then
		pcall(Kocos.panickf, "Tick error: %s\n", err)
		justDie()
	end
end
