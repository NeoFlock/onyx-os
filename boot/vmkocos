Kocos={}_KVERSION="KOCOS v0.-1.0"_OSVERSION=_OSVERSION or"Unnamed KOCOS"local argv={...}Kocos.biosBootTime=computer.uptime()Kocos.args={}if argv[1]=="kocos"then Kocos.args=argv[2]elseif not argv[1]then else error("Unknown boot protocol! This is catastrophic")end Kocos.disableScreen=false Kocos.disableScreenLogging=false Kocos.disableDefaultPanicHandler=false Kocos.hostname=Kocos.args.hostname or"localhost"Kocos.args.minLog=Kocos.args.minLog or 1 function Kocos.poweroff(reboot)Kocos.event.notifyListeners("poweroff",reboot)computer.shutdown(reboot)end package={}package.preload={}package.loaded={}package.path=Kocos.args.packagePath or"/lib/?.lua;/lib/?/init.lua;?.lua;?/init.lua;/usr/lib/?.lua;/usr/lib/?/init.lua;/usr/local/lib/?.lua;/usr/local/lib/?/init.lua"package.cpath=Kocos.args.packageCPath or"lib?.so;/lib/lib?.so;/usr/lib/lib?.so;/usr/local/lib/lib?.so"package.config="/\n;\n?\n!\n-"function table.copy(t)if type(t)=="table"then local nt={}for k,v in pairs(t)do nt[k]=v end return nt else return t end end local luaglobals={"_VERSION","_OSVERSION","_KVERSION","assert","error","getmetatable","ipairs","next","pairs","pcall","rawequal","rawget","rawset","rawlen","select","setmetatable","tonumber","tostring","type","xpcall","bit32","table","string","math","debug","os","checkArg","unicode","utf8","coroutine","load","syscall","require","package","writefile","readfile","loadfile","dofile",}function table.luaglobals(src)src=src or _G local namespace={}namespace._G=namespace for _,k in ipairs(luaglobals)do namespace[k]=table.copy(src[k])end namespace.package.loaded={}return namespace end function table.reverse(t)local mid=math.ceil(#t/2)for i=1,mid do local j=#t-i+1 local tmp=t[i]t[i]=t[j]t[j]=tmp end return t end local function isGoodKey(s)return type(s)=="string"and string.contains(s,"^[_a-zA-Z][_a-zA-Z0-9]*$",true)end local function color(s,c)if not c then return s end return c..s.."\x1b[0m"end table.colorTypeInfo={["nil"]="\x1b[34m",boolean="\x1b[34m",number="\x1b[92m",string="\x1b[32m",table="\x1b[90m",thread="\x1b[35m",["function"]="\x1b[35m",["userdata"]="\x1b[35m",docs="\x1b[33m",}function table.serialize(val,refs,colorinfo)refs=refs or{}colorinfo=colorinfo or{}if type(val)=="table"then if refs[val]then return color("...",colorinfo.table)end refs[val]=true if getmetatable(val)and getmetatable(val).__tostring then return color(tostring(val),colorinfo.docs)end local s=color("{",colorinfo.table)local list={}local done={}for i,item in ipairs(val)do done[i]=true table.insert(list,table.serialize(item,refs,colorinfo))end for k,v in pairs(val)do if not done[k]then done[k]=true local pair=""if isGoodKey(k)then pair=k else pair="["..table.serialize(k,refs,colorinfo).."]"end k=pair.." = "..table.serialize(v,refs,colorinfo)table.insert(list,k)end end s=s..table.concat(list,", ")s=s..color("}",colorinfo.table)return s elseif type(val)=="string"then return color(string.format("%q",val),colorinfo.string)else return color(tostring(val),colorinfo[type(val)])end end function table.deserialize(s)return assert(load("return "..s,nil,nil,{inf=1/0,nan=-(0/0),}))()end function table.contains(t,v)for i,x in ipairs(t)do if v==x then return true,i end end return false end function string.memformat(memory,spacing)spacing=spacing or""local units={"B","KiB","MiB","GiB","TiB","PiB"}local scale=1024 while#units>1 and memory>=scale do memory=memory/scale table.remove(units,1)end return string.format("%.2f%s%s",memory,spacing,units[1])end function string.contains(s,sub,pattern)return string.find(s,sub,nil,not pattern)~=nil end function string.split(inputstr,sep)if sep==nil then sep="%s"end if sep==""then sep="."else sep="[^"..sep.."]*"end local t={}for str in string.gmatch(inputstr,"("..sep..")")do table.insert(t,str)end return t end function string.startswith(s,prefix)return s:sub(1,#prefix)==prefix end function string.endswith(s,suffix)return s:sub(-#suffix)==suffix end function string.leftpad(s,l,c)if#s>l then return s end c=c or" "return string.rep(c,l-#s)..s end function string.rightpad(s,l,c)if#s>l then return s end c=c or"\0"return s..string.rep(c,l-#s)end function string.random(n)local t={""}for _=1,n do table.insert(t,string.char(math.random(0,255)))end return table.concat(t)end function math.clamp(x,min,max)return math.min(max,math.max(x,min))end function math.map(x,min1,max1,min2,max2)return min2+((x-min1)/(max1-min1))*(max2-min2)end function math.align(x,alignment)local off=(alignment-(x%alignment))%alignment return x+off,off end function string.binToGUID(bin)local digits4="0123456789abcdef"local base16d=""for i=1,16 do local byte=string.byte(bin,i,i)if not byte then byte=0 end local upper=math.floor(byte/16)+1 local lower=byte%16+1 base16d=base16d..digits4:sub(upper,upper)..digits4:sub(lower,lower)end local guid=base16d:sub(1,8).."-"..base16d:sub(9,12).."-"..base16d:sub(13,16).."-"..base16d:sub(17,20).."-"..base16d:sub(21)return guid end function string.randomGUID()local buf=""for _=1,16 do buf=buf..string.char(math.random(0,255))end return string.binToGUID(buf)end function string.uptimefmt(t)local hours=math.floor(t/3600)local mins=math.floor(t/60)%60 local secs=t%60 return string.format("%02d:%02d:%02.3f",hours,mins,secs)end function string.boottimefmt(t)local hours=math.floor(t/3600)local mins=math.floor(t/60)%60 local secs=t%60 return string.format("%02dh%02dm%02.3fs",hours,mins,secs)end function package.searchpath(name,path,sep,rep)sep=sep or"."rep=rep or"/"name=name:gsub("%"..sep,rep)local paths=string.split(path,';')for _,p in ipairs(paths)do local toCheck=p:gsub("%?",name)if syscall("exists",toCheck)then return toCheck end end end function dofile(filename,...)return assert(loadfile(filename))(...)end function loadfile(filename,mode,env)local code,err=readfile(filename)if not code then return nil,err end if code:sub(1,2)=="#!"then local ln=string.find(code,"\n")or#code code=code:sub(ln+1)end return load(code,"="..filename,mode,env)end function readfile(filename,bufsize)local fd,err=syscall("open",filename,"r")if err then return nil,err end local code={}while true do local data,err2=syscall("read",fd,bufsize or math.huge)if err2 then syscall("close",fd)return nil,err2 end if not data then break end table.insert(code,data)end syscall("close",fd)return table.concat(code)end function writefile(filename,data)local fd,err=syscall("open",filename,"w")if not fd then return false,err end local ok,err2=syscall("write",fd,data)syscall("close",fd)return ok,err2 end Kocos.event={}Kocos.event.listeners={}Kocos.event.timers={}function Kocos.event.notifyListeners(...)for _,func in ipairs(Kocos.event.listeners)do local ok,err=xpcall(func,debug.traceback,...)if not ok then Kocos.printkf(Kocos.L_ERROR,"Signal handler error: %s",err)end end end function Kocos.event.listen(func)table.insert(Kocos.event.listeners,func)end function Kocos.event.forget(func)for i=#Kocos.event.listeners,1,-1 do if Kocos.event.listeners[i]==func then table.remove(Kocos.event.listeners,i)end end end function Kocos.event.processTimers()local toCancel={}for id,timer in pairs(Kocos.event.timers)do local now=computer.uptime()if timer.deadline<=now then timer.times=timer.times-1 timer.deadline=now+timer.interval timer.func()end if timer.times<1 then table.insert(toCancel,id)end end for _,id in ipairs(toCancel)do Kocos.event.cancel(id)end end function Kocos.event.minTimeTilNextTimer(timeleft)for _,timer in pairs(Kocos.event.timers)do local timerleft=timer.deadline-computer.uptime()timeleft=math.min(timeleft,timerleft)end return math.max(timeleft,Kocos.args.minEventPoll or 0)end function Kocos.event.timer(interval,func,times)times=times or 1 local id=#Kocos.event.timers while Kocos.event.timers[id]do id=id+1 end Kocos.event.timers[id]={interval=interval,func=func,times=times,deadline=computer.uptime()+interval,}return id end function Kocos.event.cancel(id)Kocos.event.timers[id]=nil end function Kocos.event.pull(timeout)timeout=timeout or(Kocos.args.pollInterval or 0)local deadline=computer.uptime()+timeout while true do local now=computer.uptime()local timeleft=Kocos.event.minTimeTilNextTimer(deadline-now)local s={computer.pullSignal(timeleft)}Kocos.event.processTimers()if s[1]then Kocos.event.notifyListeners(table.unpack(s))return table.unpack(s)end if now>deadline then return end end end Kocos.event.push=computer.pushSignal do local cmethods=component.methods local cinvoke=component.invoke local cproxy=component.proxy local cfields=component.fields local cdoc=component.doc local cslot=component.slot local ctype=component.type local clist=component.list local vComponents={}local vproxyCache=setmetatable({},{__mode="v"})local componentProxy={__index=function(self,key)if self.fields[key]and self.fields[key].getter then return self.invoke(key)end end,__newindex=function(self,key,value)if self.fields[key]and self.fields[key].setter then return self.invoke(key,value)elseif self.fields[key]and self.fields[key].getter then error("field is read-only")else rawset(self,key,value)end end,__pairs=function(self)local keyProxy,keyField,value return function()if not keyField then repeat keyProxy,value=next(self,keyProxy)until not keyProxy or keyProxy~="fields"end if not keyProxy then keyField,value=next(self.fields,keyField)end return keyProxy or keyField,value end end}local componentCallback={__call=function(self,...)return component.invoke(self.address,self.name,...)end,__tostring=function(self)return component.doc(self.address,self.name)or"function"end}function component.add(vdev)if component.type(vdev.address)then return end vComponents[vdev.address]=vdev Kocos.event.push("component_added",vdev.address,vdev.type)return vdev.address end function component.remove(address)local v=vComponents[address]if not v then return end vComponents[address]=nil Kocos.event.push("component_removed",v.address,v.type)end function component.isVirtual(address)return vComponents[address]~=nil end function component.slot(address)checkArg(1,address,"string")local v=vComponents[address]if v then return v.slot end return cslot(address)end function component.type(address)checkArg(1,address,"string")local v=vComponents[address]if v then return v.type end return ctype(address)end function component.doc(address,method)checkArg(1,address,"string")checkArg(2,method,"string")local v=vComponents[address]if v then if not v.methods[method]then return nil,"no such method"end return v.methods[method].doc end return cdoc(address,method)end function component.methods(address)checkArg(1,address,"string")local v=vComponents[address]if v then local methods={}for name,m in pairs(v.methods)do if not m.getter and not m.setter then methods[name]=m.direct end end return methods end return cmethods(address)end function component.fields(address)checkArg(1,address,"string")local v=vComponents[address]if v then local fields={}for name,m in pairs(v.methods)do if m.getter or m.setter then fields[name]={getter=m.getter,setter=m.setter}end end return fields end return cfields(address)end function component.invoke(address,method,...)checkArg(1,address,"string")checkArg(2,method,"string")local v=vComponents[address]if v then local m=v.methods[method]if not m then return nil,"no such method"end if m.getter or m.setter then return nil,"no such method"end return v.invoke(method,...)end return cinvoke(address,method,...)end function component.proxy(address)if not component.isVirtual(address)then return cproxy(address)end local type,reason=component.type(address)if not type then return nil,reason end local slot,reason=component.slot(address)if not slot then return nil,reason end if vproxyCache[address]then return vproxyCache[address]end local fields,reason=component.fields(address)if not fields then return nil,reason end local proxy={address=address,type=type,slot=slot,fields=fields,invoke=vComponents[address].invoke}local methods,reason=component.methods(address)if not methods then return nil,reason end for method in pairs(methods)do proxy[method]=setmetatable({address=address,name=method},componentCallback)end setmetatable(proxy,componentProxy)vproxyCache[address]=proxy return proxy end function component.list(filter,exact)local t=clist(filter,exact)for addr,v in pairs(vComponents)do if filter then if exact then if v.type==filter then t[addr]=v.type end else if string.match(v.type,filter)then t[addr]=v.type end end else t[addr]=v.type end end return t end end local primCache={}function component._defaultHandler(ev,addr,type)if ev=="component_added"then if primCache[type]then return end primCache[type]=component.proxy(addr)Kocos.event.push("primary_added",type)end if ev=="component_removed"then if not primCache[type]then return end if primCache[type].address~=addr then return end Kocos.event.push("primary_removed",type)primCache[type]=nil end end setmetatable(component,{__index=function(t,key)if type(key)~="string"then return end return component.getPrimary(key)end})function component.getPrimary(type)if primCache[type]then return primCache[type]end local addr=component.list(type,true)()if not addr then return end primCache[type]=component.proxy(addr)return primCache[type]end function component.hasPrimary(type)return component.getPrimary(type)~=nil end Kocos.event.listen(component._defaultHandler)Kocos.L_DEBUG=0 Kocos.L_INFO=1 Kocos.L_AUTOFIX=2 Kocos.L_WARN=3 Kocos.L_ERROR=4 Kocos.L_PANIC=5 local oc=component.list("ocelot")()function Kocos.scr_write(text)end function Kocos.scr_read(len)return nil end function Kocos._scr_reader(...)end function Kocos.scr_addrs()return{}end function Kocos.scr_ioctl(action,...)end local gpu,screen=component.list("gpu")(),component.list("screen")()if gpu and screen then component.invoke(gpu,"bind",screen)local x,y=1,1 local w,h=component.invoke(gpu,"maxResolution")local buf=""local keybuf=""local targetPid local function flush()component.invoke(gpu,"set",x-#buf,y,buf)buf=""end local function color(r,g,b)return r*0x10000+g*0x100+b end local blinkTimer=nil local lightOn=false local function swapColors()local fg=component.invoke(gpu,"getForeground")local bg=component.invoke(gpu,"getBackground")component.invoke(gpu,"setForeground",bg)component.invoke(gpu,"setBackground",fg)end local function showCursor()if lightOn then return end lightOn=true swapColors()local c=component.invoke(gpu,"get",x,y)component.invoke(gpu,"set",x,y,c)end local function hideCursor()if not lightOn then return end lightOn=false swapColors()local c=component.invoke(gpu,"get",x,y)component.invoke(gpu,"set",x,y,c)end local function toggleCursor()if lightOn then hideCursor()else showCursor()end end local function disableBlink()if not blinkTimer then return end Kocos.event.cancel(blinkTimer)blinkTimer=nil end local function enableBlink()if blinkTimer then return end blinkTimer=Kocos.event.timer(0.5,function()if Kocos.disableScreen then disableBlink()end toggleCursor()end,math.huge)end local stdClrs=Kocos.args.termStdColors or{[30]=color(0,0,0),[31]=color(205,49,49),[32]=color(13,188,121),[33]=color(229,229,16),[34]=color(36,114,200),[35]=color(188,63,188),[36]=color(17,168,205),[37]=color(229,229,229),[90]=color(85,85,85),[91]=color(255,85,85),[92]=color(85,255,85),[93]=color(255,255,85),[94]=color(59,142,234),[95]=color(255,85,255),[96]=color(85,255,255),[97]=color(255,255,255),}local defaultFg=Kocos.args.termDefaultFg or stdClrs[37]local defaultBg=Kocos.args.termDefaultBg or stdClrs[30]component.invoke(gpu,"setForeground",defaultFg)component.invoke(gpu,"setBackground",defaultBg)component.invoke(gpu,"setResolution",w,h)component.invoke(gpu,"fill",1,1,w,h," ")local color256={[0]=stdClrs[30],[1]=stdClrs[31],[2]=stdClrs[32],[3]=stdClrs[33],[4]=stdClrs[34],[5]=stdClrs[35],[6]=stdClrs[36],[7]=stdClrs[37],[8]=stdClrs[90],[9]=stdClrs[91],[10]=stdClrs[92],[11]=stdClrs[93],[12]=stdClrs[94],[13]=stdClrs[95],[14]=stdClrs[96],[15]=stdClrs[97],}local esc=nil for red=0,5 do for green=0,5 do for blue=0,5 do local code=16+(red*36)+(green*6)+blue local r,g,b=0,0,0 if red~=0 then r=red*40+55 end if green~=0 then g=green*40+55 end if blue~=0 then b=blue*40+55 end color256[code]=color(r,g,b)end end end for gray=0,23 do local level=gray*10+8 local code=232+gray color256[code]=color(level,level,level)end local isKeyUpEnabled=false local sx,sy=1,1 local MAX_ESC=1*1024 local function doCSI(contents,action)local params=""while#contents>0 and contents:byte()>=0x30 and contents:byte()<=0x3F do params=params..contents:sub(1,1)contents=contents:sub(2)end local nums=string.split(params,";")for i=1,#nums do nums[i]=tonumber(nums[i])end if action=="A"then local n=nums[1]or 1 y=math.clamp(y-n,1,h)return end if action=="B"then local n=nums[1]or 1 y=math.clamp(y+n,1,h)return end if action=="C"then local n=nums[1]or 1 x=math.clamp(x+n,1,w)return end if action=="D"then local n=nums[1]or 1 x=math.clamp(x-n,1,w)return end if action=="E"then local n=nums[1]or 1 x=1 y=math.clamp(y+n,1,h)return end if action=="F"then local n=nums[1]or 1 x=1 y=math.clamp(y-n,1,h)return end if action=="G"then local n=nums[1]or 1 x=math.clamp(n,1,w)return end if action=="H"then local n=nums[1]or 1 local m=nums[2]or 1 x=math.clamp(n,1,w)y=math.clamp(m,1,h)return end if action=="J"then local n=nums[1]or 0 if n==0 then component.invoke(gpu,"fill",x,y,w-x+1,1," ")component.invoke(gpu,"fill",1,y+1,1,h-y," ")elseif n==1 then component.invoke(gpu,"fill",1,1,1,y-1," ")component.invoke(gpu,"fill",1,y,x,1," ")elseif n==2 then component.invoke(gpu,"fill",1,1,w,h," ")end return end if action=="K"then local n=nums[1]or 0 if n==0 then component.invoke(gpu,"fill",x,y,w-x+1,1," ")elseif n==1 then component.invoke(gpu,"fill",1,y,x,1," ")elseif n==2 then component.invoke(gpu,"fill",1,y,w,1," ")end return end if action=="S"then local n=nums[1]or 1 component.invoke(gpu,"copy",1,1,w,h,0,n)component.invoke(gpu,"fill",1,1,w,n," ")y=math.clamp(y-n,1,h)return end if action=="T"then local n=nums[1]or 1 component.invoke(gpu,"copy",1,1,w,h,0,-n)component.invoke(gpu,"fill",1,h-n+1,w,n," ")y=math.clamp(y-n,1,h)return end if action=="m"then local function pop()return table.remove(nums,1)or 0 end if#nums==0 then nums={0}end while#nums>0 do local op=pop()if op==0 then component.invoke(gpu,"setForeground",defaultFg)component.invoke(gpu,"setBackground",defaultBg)elseif op==7 then swapColors()elseif op==8 then elseif op==28 then elseif op>=30 and op<=37 then component.invoke(gpu,"setForeground",stdClrs[op])elseif op>=90 and op<=97 then component.invoke(gpu,"setForeground",stdClrs[op])elseif op>=40 and op<=47 then component.invoke(gpu,"setBackground",stdClrs[op-10])elseif op>=100 and op<=107 then component.invoke(gpu,"setBackground",stdClrs[op-10])elseif op==38 then local clr=defaultFg local n=pop()if n==5 then clr=color256[pop()]elseif n==2 then local r=pop()local g=pop()local b=pop()clr=color(r,g,b)end component.invoke(gpu,"setForeground",clr)elseif op==48 then local clr=defaultBg local n=pop()if n==5 then clr=color256[pop()]elseif n==2 then local r=pop()local g=pop()local b=pop()clr=color(r,g,b)end component.invoke(gpu,"setBackground",clr)elseif op==39 then component.invoke(gpu,"setForeground",defaultFg)elseif op==49 then component.invoke(gpu,"setBackground",defaultBg)end end return end if action=="n"then if nums[1]==6 then keybuf=keybuf..string.format("\x1b[%d;%dR",x,y)return end if nums[1]==7 then keybuf=keybuf..string.format("\x1b[%d;%dR",w,h)return end if nums[1]==8 then local mw,mh=component.invoke(gpu,"maxResolution")keybuf=keybuf..string.format("\x1b[%d;%dR",mw,mh)return end return end if action=="i"then return end if action=="h"then if params=="?25"then enableBlink()showCursor()return end if params=="?1004"then return end if params=="?2004"then isKeyUpEnabled=true return end return end if action=="l"then if params=="?25"then disableBlink()hideCursor()return end if params=="?1004"then return end if params=="?2004"then isKeyUpEnabled=false return end return end if action=="U"then if nums[1]==1 then component.invoke(gpu,"fill",nums[2]or 1,nums[3]or 1,nums[4]or w,nums[5]or h,unicode.char(nums[6]or 32))return end if nums[1]==2 then component.invoke(gpu,"copy",nums[2]or 1,nums[3]or 1,nums[4]or w,nums[5]or h,nums[6]or 0,nums[7]or 0)return end if nums[1]==3 then local _w=nums[2]or w local _h=nums[3]or h if component.invoke(gpu,"setResolution",_w,_h)then w=_w h=_h end return end if nums[1]==4 then local x=nums[2]or x local y=nums[3]or y local c,f,g=component.invoke(gpu,"get",x,y)keybuf=keybuf..string.format("\x1b[%d;%d;%dR",string.byte(c),f,g)return end return end if action=="v"then if nums[1]==1 then local free=component.invoke(gpu,"freeMemory")or 0 local total=component.invoke(gpu,"totalMemory")or 0 keybuf=keybuf..string.format("\x1b[%d;%dR",free,total)return end return end end local function doOSC(cmd)if cmd:sub(1,2)=="0;"then Kocos.printk(Kocos.L_WARN,cmd:sub(3))end if cmd:sub(1,2)=="1;"then local ok,_,cx,cy,msg=string.find(cmd:sub(3),"([%d+]);([%d+]);(.*)")if ok then component.invoke(gpu,"set",tonumber(cx)or x,tonumber(cy)or y,msg)end end end local lastbeep=0 local beepinterval=5 local function putc(c)if esc then if#esc==MAX_ESC then esc=nil return end if c=="7"and#esc==0 then sx,sy=x,y esc=nil return end if c=="8"and#esc==0 then x,y=sx,sy esc=nil return end if c==']'and#esc==0 then esc=']'return end if c=='['and#esc==0 then esc='['return end if esc:sub(1,1)=='['then if c:byte()>=0x40 and c:byte()<=0x7E then local ok,err=pcall(doCSI,esc:sub(2),c)esc=nil if not ok then Kocos.printk(Kocos.L_ERROR,err)end return end esc=esc..c return end if esc:sub(1,1)==']'then esc=esc..c local terms={"\a","\x1b\\"}for _,term in ipairs(terms)do if esc:sub(-#term)==term then local ok,err=pcall(doOSC,esc:sub(2,-#term-1))esc=nil if not ok then Kocos.printk(Kocos.L_ERROR,err)end return end end return end esc=nil return end if c=="\n"then flush()y=y+1 x=1 elseif c=="\r"then flush()x=1 elseif c=="\t"then flush()x=x+4 elseif c=="\a"then flush()local now=computer.uptime()if now-lastbeep>beepinterval then lastbeep=now end elseif c=="\b"then flush()if x>1 then x=x-1 component.invoke(gpu,"set",x,y," ")end elseif c=="\x1b"then flush()esc=""else buf=buf..c x=x+1 end if x>w then flush()x=1 y=y+1 end if y>h then component.invoke(gpu,"copy",1,2,w,h-1,0,-1)y=h component.invoke(gpu,"fill",1,y,w,1," ")end end function Kocos.scr_write(text)if Kocos.disableScreen then return end hideCursor()for i=1,unicode.len(text)do putc(unicode.sub(text,i,i))end flush()end local keyboard=component.invoke(screen,"getKeyboards")[1]local function isTerminalPrintable(char)return(char>=3 and char<=20)or(char>=32)end local keysHeld={}function Kocos._scr_reader(ev,kbAddr,chr,cod)if Kocos.disableScreen then return end if kbAddr~=keyboard then return end local mods=0 local ctrl=false if keysHeld[0x2A]or keysHeld[0x36]then mods=mods+1 end if keysHeld[0x38]or keysHeld[0xB8]then mods=mods+2 end if keysHeld[0x1D]or keysHeld[0x9D]then mods=mods+4 ctrl=true end if keysHeld[0]then mods=mods+8 end if ev=="key_down"then keysHeld[cod]=true local target=Kocos.process.allProcs[targetPid]if ctrl then if cod==0x20 then keybuf=keybuf..string.char(4)return end if cod==0x2E then if target then Kocos.process.raise(target,Kocos.process.SIGINT)else keybuf=keybuf..string.char(3)end return end end if chr==3 then if target then Kocos.process.raise(target,Kocos.process.SIGINT)else keybuf=keybuf..string.char(3)end return end if isTerminalPrintable(chr)then keybuf=keybuf..unicode.char(chr)return end if chr==0x1b then keybuf=keybuf.."\x1b\x1b"return end if mods==0 then keybuf=keybuf..string.format("\x1b[%d;%d~",chr,cod)else keybuf=keybuf..string.format("\x1b[%d;%d;%d~",chr,cod,mods)end return end if ev=="key_up"then keysHeld[cod]=false if isKeyUpEnabled then if mods==0 then keybuf=keybuf..string.format("\x1b[%d;%d^",chr,cod)else keybuf=keybuf..string.format("\x1b[%d;%d;%d^",chr,cod,mods)end end return end if ev=="clipboard"then keybuf=keybuf.."\x1b["..tostring(#chr).."|"..chr return end end function Kocos.scr_read(len)if Kocos.disableScreen then return end len=math.min(len,#keybuf)local oldbuf=keybuf:sub(1,len)keybuf=keybuf:sub(len+1)return oldbuf end function Kocos.scr_addrs()return{gpu,screen,keyboard}end function Kocos.scr_ioctl(action,...)if action=="setfgpid"then targetPid=...return end if action=="terminfo"then local hw_features={}local depth=component.invoke(gpu,"getDepth")local hasVRAM=component.invoke(gpu,"totalMemory")if depth>1 then table.insert(hw_features,"color")end if depth>4 then table.insert(hw_features,"truecolor")end if hasVRAM then table.insert(hw_features,"vrambuf")end return{termname="kocos-vtty-gpu",hw=Kocos.scr_addrs(),hw_features=hw_features,term_features={"ansicolor","256color","truecolor","gpu","vrambuf",},columns=w,lines=h,}end return nil,Kocos.errno.EINVAL end end Kocos.event.listen(Kocos._scr_reader)function Kocos.writelog(text)if oc and not Kocos.args.noOcelotLog then component.invoke(oc,"log",text)end if Kocos.disableScreenLogging then return end Kocos.scr_write(text)end function Kocos.printk(severity,msg)local uptime=computer.uptime()Kocos.event.notifyListeners("kocos_log",uptime,severity,msg)if Kocos.args.minLog then if severity<Kocos.args.minLog then return end end local names={[Kocos.L_DEBUG]="DEBUG",[Kocos.L_INFO]="INFO",[Kocos.L_AUTOFIX]="AUTOFIX",[Kocos.L_WARN]="WARN",[Kocos.L_ERROR]="ERROR",[Kocos.L_PANIC]="PANIC",}local colors={[Kocos.L_DEBUG]=2,[Kocos.L_INFO]=12,[Kocos.L_AUTOFIX]=8,[Kocos.L_WARN]=3,[Kocos.L_ERROR]=1,[Kocos.L_PANIC]=9,}local color,reset="",""color="\x1b[38;5;"..tostring(colors[severity]or 0).."m"reset="\x1b[0m"local rawText=string.format("[%5.3f %s%s%s] %s\n",uptime,color,names[severity]or"UNKNOWN",reset,msg)Kocos.writelog(rawText)if severity==Kocos.L_PANIC then if Kocos.disableDefaultPanicHandler then Kocos.event.notifyListeners("kocos_panic",uptime,msg)return end pcall(Kocos.event.pull,5)computer.shutdown(true)end end function Kocos.printkf(severity,fmt,...)Kocos.printk(severity,string.format(fmt,...))end function Kocos.panick(msg)Kocos.printk(Kocos.L_PANIC,msg)end function Kocos.panickf(fmt,...)Kocos.panick(string.format(fmt,...))end Kocos.printk(Kocos.L_DEBUG,"printk loaded")local errno={}errno.E2BIG="too many arguments"errno.EACCESS="permission denied"errno.EAGAIN="resource temporarily unavailable"errno.EBADF="bad file descriptor"errno.EBADMSG="bad message"errno.ECHILD="no child processes"errno.EEXIST="file exists"errno.EFBIG="file too large"errno.EHWPOISON="critical driver error"errno.EINVAL="invalid argument"errno.EIO="I/O error"errno.EISDIR="is a directory"errno.ELIBACC="cannot access shared library"errno.ELIBBAD="invalid shared library"errno.ELIBEXEC="cannot exec a shared library"errno.ELOOP="too many symbolic links"errno.ENAMETOOLONG="name too long"errno.ENODEV="no such device"errno.ENOENT="no such file or directory"errno.ENOEXEC="exec format error"errno.ENOSYS="invalid syscall"errno.ENOTBLK="block device required"errno.ENOTDIR="not a directory"errno.ENOTEMPTY="directory not empty"errno.ENOTSOCK="not a socket"errno.EPERM="operation not permitted"errno.EPIPE="broken pipe"errno.EPROTO="protocol error"errno.EPROTONOSUPPORT="protocol not supported"errno.EPROTOTYPE="protocol wrong type for socket"errno.ERESTART="syscall requires restart"errno.ESPIPE="invalid seek"errno.ESRCH="no such process"errno.ESTRPIPE="streams pipe error"errno.ETIME="timer expired"errno.EUNATCH="driver not attached"errno.ENODRIVER=errno.EUNATCH errno.ETIMEDOUT="connection timed out"errno.EROFS="read-only filesystem"errno.ENETDOWN="network is down"errno.EISCONN="socket is connected"errno.ECANCELED="operation cancelled"errno.EALREADY="connection already in progress"errno.EADDRINUSE="address already in use"errno.EADDRNOTAVAIL="address not available"errno.EAFNOSUPPORT="address family not supported"errno.EXDEV="invalid cross-device link"errno.EHOSTISDOWN="host is unreachable"Kocos.errno=errno Kocos.drivers={}function Kocos.addDriver(driver)table.insert(Kocos.drivers,1,driver)Kocos.event.notifyListeners("driver_added",driver)end function Kocos.removeDriver(driver)for i=#Kocos.drivers,1,-1 do if Kocos.drivers[i]==driver then table.remove(Kocos.drivers,i)end end Kocos.event.notifyListeners("driver_removed",driver)end Kocos.printk(Kocos.L_DEBUG,"driver system loaded")do Kocos.printk(Kocos.L_DEBUG,"debugger subsystem loaded")local event=Kocos.event local function respond(resp)event.push("kgdb_resp",resp)end local function respondf(fmt,...)respond(string.format(fmt,...))end _BreakInfo=nil function _WRAP_BREAKPOINT(f,name)if type(f)=="table"then return f.func else return setmetatable({func=f,},{__tostring=function()return tostring(f)end,__call=function(t,...)_BreakInfo={args={...},bt=debug.traceback(name),last=_BreakInfo}respondf("Hit breakpoint %s",name or"unnamed")while true do local e=Kocos.event.pull(math.huge)if e=="kgdb_go"then break end end local ret={f(...)}_BreakInfo.rets=ret while true do local e=Kocos.event.pull(math.huge)if e=="kgdb_go"then _BreakInfo=_BreakInfo.last break end end respondf("Breakpoint %s over",name or"unnamed")return table.unpack(ret)end,})end end event.listen(function(ev,command)if ev~="kgdb_msg"then return end if command=="h"then respond([[
h - Display this help page
l <code> - Run Lua code as a statement
x <code> - Run Lua code as an expression (or comma-separated series of expressions) and display results
r - Reboot
R - Shutdown
m - View memory usage
e - View battery status
c - List known device hardware
c <filter> - Like c, except using a fuzzy match identical to component.list()
bp <expression> - Wrap a function to trigger a breakpoint. This will replace the function with a table with the __call metamethod.
bt - Print the backtrace saved from the latest breakpoint
ba - Print the arguments saved from the latest breakpoint
br - Print the returns saved from the latest breakpoint
g - Go, aka, run past breakpoint
gc - Go, but only past the call. Still break on return. br will print the returns
]])return end if command:sub(1,3)=="bp "then local name=command:sub(4)local expr=string.format("%s = _WRAP_BREAKPOINT(%s, %q)",name,name,name)local f,err=load(expr,"=bp")if not f then respondf("Error: %s",err)return end local ok,err2=xpcall(f,debug.traceback)if err then respondf("Error: %s",err2)return end respondf("Toggled breakpoint %s",name)return end if command=="gc"then if _BreakInfo.rets then return respond("Call already resumed")end Kocos.event.push("kgdb_go")return respond("Call skipped")end if command=="g"then if not _BreakInfo.rets then Kocos.event.push("kgdb_go")end Kocos.event.push("kgdb_go")return end if command=="bt"then if _BreakInfo then return respond(_BreakInfo.bt)else return respond("No backtrace")end end if command=="ba"then if not _BreakInfo then return respond("No breakpoint info")end local t={}for i=1,#_BreakInfo.args do t[i]=table.serialize(_BreakInfo.args[i])end return respond(table.concat(t,", "))end if command=="br"then if not _BreakInfo then return respond("No breakpoint info")end if not _BreakInfo.rets then return respond("Call still suspended")end local t={}for i=1,#_BreakInfo.rets do t[i]=table.serialize(_BreakInfo.rets[i])end return respond(table.concat(t,", "))end if command=="c"or command:sub(1,2)=="c "then local filter=nil if command:sub(1,2)=="c "then filter=command:sub(3)end local buf={}for addr,type in component.list(filter)do table.insert(buf,addr.." = "..type)end respond(table.concat(buf,"\n"))return end if command=="m"then local total=computer.totalMemory()local free=computer.freeMemory()local used=total-free respondf("Total: %s\nUsed: %s (%3.2f%%)\nFree: %s (%3.2f%%)\n",string.memformat(total),string.memformat(used),used/total*100,string.memformat(free),free/total*100)return end if command=="e"then local total=computer.maxEnergy()local remaining=computer.energy()respondf("Energy: %d FE / %d FE (%3.2f%%)",remaining,total,remaining/total*100)return end if command=="r"then respond("Rebooting...")Kocos.poweroff(true)return end if command=="R"then respond("Shutting down...")Kocos.poweroff(false)return end if command:sub(1,2)=="l "then local code=command:sub(3)local f,err=load(code,"=kgdb")if not f then respondf("Error: %s",err)return end local ok,err2=xpcall(f,debug.traceback)if not ok then respondf("Error: %s",err2)return end respondf("OK")return end if command=="nproc"then local nproc=0 for pid in pairs(Kocos.process.allProcs)do nproc=nproc+1 end return respond(tostring(nproc))end if command=="pids"then local pids={}for pid in pairs(Kocos.process.allProcs)do table.insert(pids,pid)end return respond(table.concat(pids," "))end if command:sub(1,2)=="x "then local code=command:sub(3)local f,err=load("return "..code,"=kgdb")if not f then respondf("Error: %s",err)return end local t={xpcall(f,debug.traceback)}if not t[1]then respondf("Error: %s",t[2])return end local strs={}for i=2,#t do strs[i-1]=table.serialize(t[i])end if#strs==0 then strs={"nil"}end respond(table.concat(strs,", "))return end end)local kgdb=Kocos.args.debugger if kgdb then local kgdbType=component.type(kgdb)or"unknown"Kocos.printk(Kocos.L_DEBUG,"Using debugger: "..kgdb.." ("..kgdbType..")")if kgdbType=="ocelot"then event.listen(function(ev,hw,msg)if ev=="ocelot_message"and hw==kgdb then event.push("kgdb_msg",msg)end if ev=="kgdb_resp"then component.invoke(kgdb,"log","[KGDB] "..hw)end end)elseif kgdbType=="tunnel"then elseif kgdbType=="modem"then end respond("debugger connection established")else Kocos.printk(Kocos.L_DEBUG,"No debugger selected")end end do local function processPathParts(ramfs,path)local node=ramfs.image while#path>0 do local name=table.remove(path,1)if not node.items then return end node=node.items[name]if not node then return end end return node end local function processPath(ramfs,path)local s=string.split(Kocos.fs.canonical(path):sub(2),"/")return processPathParts(ramfs,s)end local function processParentPath(ramfs,path)local s=string.split(Kocos.fs.canonical(path):sub(2),"/")local name=s[#s]s[#s]=nil return processPathParts(ramfs,s),name end function Kocos.addRamfsComponent(ramfs,address)address=address or string.randomGUID()return component.add{address=address,type="filesystem",slot=-1,methods={spaceUsed={direct=true},spaceTotal={direct=true},getLabel={direct=true},setLabel={direct=true},exists={direct=true},size={direct=true},list={direct=true},isDirectory={direct=true},isReadOnly={direct=true},lastModified={direct=true},makeDirectory={direct=true},open={direct=true},write={direct=true},read={direct=true},seek={direct=true},close={direct=true},remove={direct=true},rename={direct=true},},invoke=function(method,...)if method=="spaceUsed"then return computer.totalMemory()-computer.freeMemory()end if method=="spaceTotal"then return computer.totalMemory()end if method=="getLabel"then return ramfs.label end if method=="setLabel"then ramfs.label=tostring((...))return ramfs.label end if method=="exists"then local p=...if p==""then return true end return processPath(ramfs,p)~=nil end if method=="size"then local p=...if p==""then return 0 end local node=processPath(ramfs,p)if not node then return 0 end if not node.fileData then return 0 end return#node.fileData end if method=="list"then local p=...local node=p==""and ramfs.image or processPath(ramfs,p)if not node then return nil,"no such file"end if not node.items then return end local items={}for name,child in pairs(node.items)do if child.items then table.insert(items,name.."/")else table.insert(items,name)end end return items end if method=="isDirectory"then local p=...if p==""then return true end local node=processPath(ramfs,p)if not node then return false end return node.items~=nil end if method=="isReadOnly"then return ramfs.readonly end if method=="lastModified"then return 0 end if method=="makeDirectory"then local p=...local parent,name=processParentPath(ramfs,p)if not parent then return false,p end if not parent.items then return false,p end parent.items[name]=parent.items[name]or{items={}}return true end if method=="open"then local p,m=...m=m or"r"if ramfs.readonly and m~="r"then return nil,"readonly"end local n=processPath(ramfs,p)if m=="r"and not n then return nil,p end if not n then if ramfs.readonly then return nil,"readonly"end n={fileData="",}local parent,name=processParentPath(ramfs,p)if not parent then return nil,p end if not parent.items then return nil,p end parent.items[name]=n end if not n.fileData then return nil,"is a directory"end local fd=#ramfs.fds+1 ramfs.fds[fd]={mode=m,offset=m=="a"and#n.fileData or 0,node=n,}if m=="w"then n.fileData=""end return fd end if method=="write"then local fd,data=...local f=ramfs.fds[fd]if not f then return false,"bad file"end if f.mode=="r"then return false,"bad file"end local buf=f.node.fileData or""if f.mode=="a"then f.offset=#buf end buf=buf:sub(1,f.offset)..data..buf:sub(f.offset+#data)f.node.fileData=buf f.offset=f.offset+#data return true end if method=="seek"then local fd,whence,off=...whence=whence or"cur"off=0 off=math.floor(off)local f=ramfs.fds[fd]if not f then return false,"bad file"end local len=#f.node.fileData if whence=="set"then f.offset=off elseif whence=="cur"then f.offset=f.offset+off elseif whence=="end"then f.offset=len-f.offset end f.offset=math.clamp(f.offset,0,len)return f.offset end if method=="read"then local fd,len=...local f=ramfs.fds[fd]if not f then return nil,"bad file"end if f.mode~="r"then return nil,"bad file"end local buf=f.node.fileData or""len=len or#buf len=math.min(len,#buf-f.offset)if f.offset>=#buf then return end local chunk=buf:sub(f.offset+1,f.offset+len)f.offset=f.offset+#chunk return chunk end if method=="close"then ramfs.fds[(...)]=nil return end if method=="remove"then local p=...local parent,name=processParentPath(ramfs,p)if not parent then return false,p end if parent.items[name]then parent.items[name]=nil end return true end if method=="rename"then return false,"unsupported"end end,}end end local fs={}fs.FTYPE_NONE="none"fs.FTYPE_REGF="regular"fs.FTYPE_DIR="directory"fs.FTYPE_MNT="mount"fs.FTYPE_BLK="blockdev"fs.FTYPE_CHR="chardev"fs.O_NONBLOCK=1 fs.O_CLOEXEC=2 fs.F_GETFL="F_GETFL"fs.F_SETFL="F_SETFL"fs.F_SETCB="F_SETCB"fs.F_NOTIF="F_NOTIF"fs.EV_CLOSED="closed"fs.EV_DATAREADY="data-ready"fs.EV_WRITEDONE="write-done"function fs.getVirtualDrive(drive)if drive.type=="drive"then return drive end if drive.type=="partition"then return drive end for _,driver in ipairs(Kocos.drivers)do local virt=driver("FS-vdrive",drive)if virt then return virt end end end function fs.getPartitionsOf(drive)for _,driver in ipairs(Kocos.drivers)do local parts=driver("FS-getpartitions",drive)if parts then return parts end end end fs.allMounts={}fs.root=nil function fs.mount(dev)local mountID=dev.address if fs.allMounts[mountID]then fs.allMounts[mountID].mountc=fs.allMounts[mountID].mountc+1 return fs.allMounts[mountID]end for _,driver in ipairs(Kocos.drivers)do local fsid,driverData=driver("FS-mount",dev)if fsid then fs.allMounts[mountID]={mountc=1,dev=dev,submounts={},fsid=fsid,driverData=driverData,driver=driver,}return fs.allMounts[mountID]end end end function fs.unmount(mountpoint)if not mountpoint.fsid then return end mountpoint.fsid=nil mountpoint.mountc=mountpoint.mountc-1 if mountpoint.mountc>0 then return end fs.allMounts[mountpoint.dev.address]=nil for _,mount in pairs(mountpoint.submounts)do fs.unmount(mount)end if mountpoint.driver then mountpoint.driver("FS-unmount",mountpoint.driverData)end end function fs.syncMount(mountpoint)if mountpoint.driver then mountpoint.driver("FS-syncAll",mountpoint.driverData)end end function fs.sync()for _,mount in pairs(fs.allMounts)do fs.syncMount(mount)end end function fs.canonical(path)if path:sub(1,1)=="/"then path=path:sub(2)end local parts=string.split(path,"%/")local stack={}for _,part in ipairs(parts)do if#part>0 then table.insert(stack,part)if part==string.rep(".",#part)then for _=1,#part do stack[#stack]=nil end end end end return"/"..table.concat(stack,"/")end function fs.join(...)return fs.canonical(table.concat({...},"/"))end function fs.parentPath(p)p=fs.canonical(p):sub(2)local parts=string.split(p,"/")local name=table.remove(parts,1)return"/"..table.concat(parts,"/"),name end function fs.fromRoot(path,root)if path==root then return"/"end if root=="/"then return path end return path:sub(#root+1)end function fs.resolve(path,ignoreLastLink)path=fs.canonical(path)while path:sub(1,1)=="/"do path=path:sub(2)end while path:sub(#path)=="/"do path=path:sub(1,-2)end local mountpoint,mountpath=fs.root,path while true do local done=true if mountpoint.submounts[mountpath]then if ignoreLastLink then break end return mountpoint.submounts[mountpath],""end for m,mp in pairs(mountpoint.submounts)do if path:sub(1,#m+1)==m.."/"then mountpoint=mp mountpath=path:sub(#m+2)done=false end end if done then break end end return mountpoint,mountpath end function fs.list(dir)if not fs.exists(dir)then return nil,Kocos.errno.ENOENT end local mnt,p=fs.resolve(dir)if not mnt.driver then return nil,Kocos.errno.ENODRIVER end local files,err=mnt.driver("FS-listDir",mnt.driverData,p)if not files then return nil,err or Kocos.errno.EHWPOISON end return files end function fs.stat(path,checklink)if not fs.exists(path,checklink)then return nil,Kocos.errno.ENOENT end local mnt,p=fs.resolve(path,checklink)if not mnt.driver then return nil,Kocos.errno.ENODRIVER end local stat,err=mnt.driver("FS-stat",mnt.driverData,p)if not stat then return nil,err or Kocos.errno.EHWPOISON end return stat end function fs.open(path,mode)if not fs.exists(path)then return nil,Kocos.errno.ENOENT end if fs.ftype(path)==fs.FTYPE_DIR then return nil,Kocos.errno.EISDIR end local mnt,p=fs.resolve(path)if not mnt.driver then return nil,Kocos.errno.ENODRIVER end return mnt.driver("FS-openFile",mnt.driverData,p,mode)end function fs.close(fd)if fd.listener then fd.listener(fs.EV_CLOSED)end if fd.close then fd:close()end end function fs.write(fd,data)if fd.write then return fd:write(data)end return false,Kocos.errno.EBADF end function fs.read(fd,len)if fd.read then return fd:read(len)end return nil,Kocos.errno.EBADF end function fs.seek(fd,whence,off)whence=whence or"set"off=off or 0 if fd.seek then return fd:seek(whence,off)end return nil,Kocos.errno.EBADF end function fs.ioctl(fd,action,...)if fd.ioctl then return fd:ioctl(action,...)end return nil,Kocos.errno.EBADF end function fs.setlistener(fd,listener)fd.listener=listener end function fs.notify(fd,ev,...)if fd.listener then fd.listener(ev,...)end end function fs.fd_from_rwf(reader,writer,finalizer,ioctl)return{read=reader,write=writer,close=finalizer,ioctl=ioctl,flags=0,}end function fs.touch(path,perms,uid,gid)local m,p=fs.resolve(path)if not m.driver then return nil,Kocos.errno.EHWPOISON end if fs.ftype(path)==fs.FTYPE_DIR then return nil,Kocos.errno.EISDIR end return m.driver("FS-touch",m.driverData,p,perms,uid,gid)end function fs.mkdir(path,perms,uid,gid)local m,p=fs.resolve(path)if not m.driver then return nil,Kocos.errno.EHWPOISON end if fs.exists(path,true)then return nil,Kocos.errno.EEXIST end return m.driver("FS-mkdir",m.driverData,p,perms,uid,gid)end function fs.ftype(path)local m,p=fs.resolve(path,true)if not m.driver then return nil,Kocos.errno.EHWPOISON end if m.submounts[p]or p==""then return fs.FTYPE_MNT end return m.driver("FS-ftype",m.driverData,p)end function fs.remove(path)local ftype,err=fs.ftype(path)if not ftype then return nil,err end if ftype==fs.FTYPE_NONE then return nil,Kocos.errno.ENOENT end if ftype==fs.FTYPE_MNT then return nil,Kocos.errno.EACCESS end if ftype==fs.FTYPE_DIR then local l,err2=fs.list(path)if not l then return nil,err2 end if#l>0 then return nil,Kocos.errno.ENOTEMPTY end end local m,p=fs.resolve(path)if not m.driver then return nil,Kocos.errno.EHWPOISON end return m.driver("FS-remove",m.driverData,p)end function fs.exists(path,checklink)local m,p=fs.resolve(path,checklink)if not m.driver then return nil,Kocos.errno.EHWPOISON end return m.driver("FS-exists",m.driverData,p)end function fs._defaultManagedFS(req,...)if req=="FS-mount"then local dev=...if dev.type~="filesystem"then return end return"managedfs",dev end if req=="FS-listDir"then local dev,path=...if not dev.isDirectory(path)then return nil,Kocos.errno.ENOTDIR end return dev.list(path)end if req=="FS-exists"then local dev,path=...return dev.exists(path)end if req=="FS-remove"then local dev,path=...return dev.remove(path)end if req=="FS-ftype"then local dev,path=...if not dev.exists(path)then return fs.FTYPE_NONE end if dev.isDirectory(path)then return fs.FTYPE_DIR end return fs.FTYPE_REGF end if req=="FS-touch"then local dev,path,perms,uid,gid=...local f,err=dev.open(path,dev.exists(path)and"w"or"a")if not f then return false,err end dev.close(f)return true end if req=="FS-mkdir"then local dev,path,perms,uid,gid=...return dev.makeDirectory(path)end if req=="FS-stat"then local dev,path=...local size=dev.size(path)or 0 return{deviceAddress=dev.address,deviceType=dev.type,size=size,createdAt=0,lastModified=dev.lastModified(path),diskSize=size,diskUsed=dev.spaceUsed(),diskTotal=dev.spaceTotal(),inode=math.random(0,2^32-1),perms=0,}end if req=="FS-openFile"then local dev,path,mode=...if dev.isDirectory(path)then return nil,Kocos.errno.EISDIR end local fd,err=dev.open(path,mode)if not fd then return nil,err end return{write=function(_,data)return dev.write(fd,data)end,read=function(_,len)return dev.read(fd,len)end,seek=function(_,whence,off)return dev.seek(fd,whence,off)end,close=function()dev.close(fd)end,flags=0,}end end Kocos.fs=fs Kocos.printk(Kocos.L_DEBUG,"filesystem subsystem loaded")Kocos.printk(Kocos.L_INFO,"registering default drivers")Kocos.addDriver(fs._defaultManagedFS)Kocos.printk(Kocos.L_INFO,"managedfs driver registered")local fs=Kocos.fs local function devfsAddrSuffix(addr)return addr:sub(1,3):upper()end local function computeDeviceFiles()local f={}for addr,type in component.list()do local name if type=="filesystem"then name="fs"..devfsAddrSuffix(addr)elseif type=="drive"then name="hd"..devfsAddrSuffix(addr)elseif type=="partition"then local devaddr=component.invoke(addr,"getDeviceAddress")or"ERR"name="hd"..devfsAddrSuffix(devaddr).."p"..devfsAddrSuffix(addr)elseif type=="serial"then name="usb"..devfsAddrSuffix(addr)elseif type=="gpu"then name="gpu"..devfsAddrSuffix(addr)elseif type=="tunnel"then name="tnl"..devfsAddrSuffix(addr)elseif type=="screen"then name="screen"..devfsAddrSuffix(addr)elseif type=="eeprom"then name="eeprom"..devfsAddrSuffix(addr)else end if name then f[name]=addr end end return f end local function devfsPathToDev(path)if string.startswith(path,"components/")then for addr in component.list()do if path=="components/"..addr then return addr end end return end for p,dev in pairs(computeDeviceFiles())do if p==path then return dev end end end local function devfsDevToFD(dev,mode)local t=component.type(dev)if t=="tunnel"then local s,err=Kocos.net.socket("AF_TUNNEL","dgram")if not s then return nil,err end local ok,err2=Kocos.net.connect(s,{address=dev,port=0})if not ok then return nil,err2 end s.flags=1 return{flags=1,write=function(_,data)if mode=="r"then return false,Kocos.errno.EBADF end return Kocos.net.write(s,data)end,read=function(_,len)if mode~="r"then return nil,Kocos.errno.EBADF end return Kocos.net.read(s,len)end,close=function()Kocos.net.close(s)end,}end if t=="serial"then return{flags=1,write=function(_,data)if mode=="r"then return false,Kocos.errno.EBADF end return component.invoke(dev,"write",data)end,read=function(_,len)if mode~="r"then return nil,Kocos.errno.EBADF end return component.invoke(dev,"read",len)end,}end if t=="drive"or t=="partition"then if mode=="a"then return nil,"bad mode"end local d=component.proxy(dev)local cursor=0 return{flags=1,read=function(_,len)if mode~="r"then return nil,Kocos.errno.EBADF end local cap=d.getCapacity()if cursor>=cap then return end len=math.min(len,cap-cursor,4*1024)local sectorSize=d.getSectorSize()local parts={}local left=len while left>0 do local off=cursor%sectorSize local sector=assert(d.readSector(1+math.floor(cursor/sectorSize)))sector=sector:sub(1+off,len+off)table.insert(parts,sector)left=left-#sector cursor=cursor+#sector end cursor=math.clamp(cursor,0,cap)return table.concat(parts)end,write=function(_,data)if mode=="r"then return false,Kocos.errno.EBADF end local cap=d.getCapacity()local sectorSize=d.getSectorSize()local left=math.min(#data,cap-cursor)while left>0 do local written=0 if cursor%sectorSize==0 and left>=sectorSize then local sec=data:sub(1,sectorSize)d.writeSector(1+cursor/sectorSize,sec)written=sectorSize else local off=cursor%sectorSize local len=math.min(left,sectorSize)local secId=1+math.floor(cursor/sectorSize)local sec=assert(d.readSector(secId))sec=sec:sub(1,off)..data:sub(1,len)..sec:sub(1+off+len)d.writeSector(secId,sec)written=len end data=data:sub(1+written)cursor=cursor+written left=left-written end cursor=math.clamp(cursor,0,cap)return true end,seek=function(_,whence,off)local cap=d.getCapacity()if whence=="set"then cursor=off elseif whence=="cur"then cursor=cursor+off elseif whence=="end"then cursor=cap-off end cursor=math.clamp(cursor,0,cap)return cursor end,ioctl=function(_,action,...)if action=="devfs:address"then return dev end if action=="devfs:slot"then return component.slot(dev)end if action=="devfs:type"then return component.type(dev)end if action=="devfs:doc"then return component.doc(dev,...)end return component.invoke(dev,action,...)end,}end return{flags=0,ioctl=function(_,method,...)if method=="devfs:address"then return dev end if method=="devfs:slot"then return component.slot(dev)end if method=="devfs:type"then return component.type(dev)end if method=="devfs:doc"then return component.doc(dev,...)end return component.invoke(dev,method,...)end,}end local function devfsMakeFD(path,mode)local errno=Kocos.errno if path=="null"then return{write=function()return true end,read=function()end,flags=0,}end if path=="zero"then if mode~="r"then return nil,errno.EPERM end return{read=function(_,len)if len==math.huge then len=4096 end return string.rep("\0",len)end,flags=0,}end if path=="random"then if mode~="r"then return nil,errno.EPERM end return{read=function(_,len)if len==math.huge then len=4096 end local c=""for _=1,len do c=c..string.char(math.random(0,255))end return c end,flags=0,}end if path=="hex"then if mode~="r"then return nil,errno.EPERM end return{read=function(_,len)if len==math.huge then len=4096 end local c=""local a="0123456789ABCDEF"for _=1,len do local i=math.random(1,16)c=c..a:sub(i,i)end return c end,flags=0,}end if path:sub(1,3)=="std"then local fd=Kocos.process["STD"..path:sub(4):upper()]if not fd then return nil,errno.ENOENT end return{write=function(_,data)return syscall("write",fd,data)end,read=function(_,len)return syscall("read",fd,len)end,ioctl=function(_,action,...)return syscall("ioctl",action,...)end,seek=function(_,whence,off)return syscall("seek",whence,off)end,flags=0,}end local dev=devfsPathToDev(path)if dev then return devfsDevToFD(dev,mode)end return nil,errno.ENOENT end function Kocos._default_devfs(req,...)if req=="FS-mount"then local dev=...if dev.type~="devfs"then return end return"devfs"end if req=="FS-mkdir"then return nil,Kocos.errno.EPERM end if req=="FS-touch"then return nil,Kocos.errno.EPERM end if req=="FS-openFile"then local _,path,mode=...return devfsMakeFD(path,mode)end if req=="FS-listDir"then local _,path=...if path==""then local files={"components","null","zero","random","hex","stdin","stderr","stdout","stdterm"}for f in pairs(computeDeviceFiles())do table.insert(files,f)end return files end if path=="components"then local f={}for addr in component.list()do table.insert(f,addr)end return f end return nil,path end if req=="FS-ftype"then local _,path=...if path==""then return fs.FTYPE_DIR end if path=="components"then return fs.FTYPE_DIR end if path=="null"then return fs.FTYPE_CHR end if path=="zero"then return fs.FTYPE_CHR end if path=="random"then return fs.FTYPE_CHR end if path=="hex"then return fs.FTYPE_CHR end if path=="stdin"then return fs.FTYPE_CHR end if path=="stderr"then return fs.FTYPE_CHR end if path=="stdout"then return fs.FTYPE_CHR end if path=="stdterm"then return fs.FTYPE_CHR end for f in pairs(computeDeviceFiles())do if path==f then return fs.FTYPE_BLK end end if string.startswith(path,"components/")then for addr in component.list()do if path=="components/"..addr then return fs.FTYPE_BLK end end end return fs.FTYPE_NONE end if req=="FS-exists"then local _,path=...if path==""then return true end if path=="components"then return true end if path=="null"then return true end if path=="zero"then return true end if path=="random"then return true end if path=="hex"then return true end if path=="stdin"then return true end if path=="stderr"then return true end if path=="stdout"then return true end if path=="stdterm"then return true end for f in pairs(computeDeviceFiles())do if path==f then return true end end return false end if req=="FS-stat"then local _,path=...local dev=devfsPathToDev(path)if dev then local ctype=component.type(dev)local size=0 local used=0 if ctype=="filesystem"then used=component.invoke(dev,"spaceUsed")size=component.invoke(dev,"spaceTotal")elseif ctype=="drive"or ctype=="partition"then size=component.invoke(dev,"getCapacity")end return{deviceAddress=dev,deviceType=ctype,size=size,createdAt=0,lastModified=0,diskUsed=used,diskTotal=size,inode=math.random(0,2^32-1),perms=0,}end return{deviceAddress="devfs",deviceType="devfs",size=0,createdAt=0,lastModified=0,diskUsed=0,diskTotal=0,inode=math.random(0,2^32-1),perms=0,}end end Kocos.printk(Kocos.L_DEBUG,"devfs subsystem loaded")Kocos.printk(Kocos.L_DEBUG,"adding devfs driver")Kocos.addDriver(Kocos._default_devfs)Kocos.printk(Kocos.L_DEBUG,"adding devfs component")component.add{address="devfs",type="devfs",invoke=function()end,methods={},slot=-1,}local process={}process.npid=0 process.STDIN=0 process.STDOUT=1 process.STDERR=2 process.STDTERM=3 process.allProcs={}process.daemons={}function process.nextPid()if Kocos.args.useExtremelySecurePidGeneration then local pid=math.random(1,2^32-1)while process.allProcs[pid]do pid=math.random(1,2^32-1)end return pid end local pid=process.npid process.npid=process.npid+1 return pid end function process.create(thread,namespace,uid,gid)local pid=process.nextPid()local proc={pid=pid,uid=uid,gid=gid,euid=uid,egid=gid,thread=thread,namespace=namespace,args={},env={},modules={},deps={},fds={},signals={},children={},stopped=false,state="running",cwd="/",root="/",exitcode=0,blockUntil={},proclocal={},}process.allProcs[pid]=proc return proc end function process.fork(proc,func)local forked=process.create(coroutine.create(func),proc.namespace,proc.uid,proc.gid)forked.euid=proc.euid forked.egid=proc.egid forked.args=table.copy(proc.args)forked.env=table.copy(proc.env)forked.blockUntil=table.copy(proc.blockUntil)forked.modules=proc.modules forked.deps=proc.deps for fd,res in pairs(proc.fds)do forked.fds[fd]=res res.refc=res.refc+1 end forked.stopped=proc.stopped forked.cwd=proc.cwd forked.root=proc.root forked.exitcode=proc.exitcode forked.tracer=proc.tracer forked.parent=proc forked.exe=proc.exe proc.children[forked.pid]=forked return forked end function process.isDecendantOf(proc,parent)while parent do if proc.parent==parent then return true end parent=parent.parent end return false end process.SIGABRT="SIGABRT"process.SIGALRM="SIGALRM"process.SIGTERM="SIGTERM"process.SIGKILL="SIGKILL"process.SIGUSR1="SIGUSR1"process.SIGUSR2="SIGUSR2"process.SIGCHLD="SIGCHLD"process.SIGINT="SIGINT"process.SIGPIPE="SIGPIPE"process.SIGQUIT="SIGQUIT"process.SIGSTOP="SIGSTOP"process.SIGTSTP="SIGTSTP"process.SIGSYS="SIGSYS"process.SIGWINCH="SIGWINCH"process.SIGURG="SIGURG"process.SIGTRAP="SIGTRAP"process.SIGCONT="SIGCONT"process.SIGSYSC="SIGSYSC"process.SIGSYSR="SIGSYSR"process.SIGPWR="SIGPWR"function process.raise(proc,signal,...)if not proc then return end if signal==process.SIGSTOP then proc.stopped=true if process.current==proc then coroutine.yield()end return end if signal==process.SIGKILL then process.terminate(proc)return end if signal==process.SIGCONT then proc.stopped=false return end if proc.stopped then return end if proc.signals[signal]then process.pcall(proc,proc.signals[signal],...)else if signal==process.SIGINT then process.terminate(proc)return end if signal==process.SIGPIPE then process.terminate(proc)return end if signal==process.SIGUSR1 then process.terminate(proc)return end if signal==process.SIGUSR2 then process.terminate(proc)return end if signal==process.SIGTRAP then local err=...if type(err)=="string"then process.pcall(proc,syscall,"write",process.STDERR,err.."\n")end process.terminate(proc)return end if signal==process.SIGTERM then process.terminate(proc)return end end if signal==process.SIGABRT then process.terminate(proc,1)return end end function process.xpcall(proc,f,msgh,...)local oldCurProc=process.current process.current=proc local t={xpcall(f,msgh,...)}process.current=oldCurProc return table.unpack(t)end function process.pcall(proc,f,...)return process.xpcall(proc,f,tostring,...)end function process.closeResource(res)res.refc=res.refc-1 if res.refc>0 then return end if res.file then Kocos.fs.close(res.file)end if res.socket then Kocos.net.close(res.socket)end end function process.moveResource(proc,res)local fd=0 while proc.fds[fd]do fd=fd+1 end proc.fds[fd]=res return fd end function process.terminate(proc,exit)if proc.state~="running"then return end proc.state="finished"proc.exitcode=exit or 1 if proc==process.root then Kocos.panickf("KERNEL EXITED: %d",proc.exitcode)return end if proc==Kocos.process.init then Kocos.panickf("INIT EXITED: %d",proc.exitcode)return end if proc.parent then process.raise(proc.parent,process.SIGCHLD,proc.pid,proc.exitcode)end process.raise(proc,process.SIGABRT)if proc.driver then Kocos.removeDriver(proc.driver)proc.driver=nil end if proc.ev_listener then Kocos.event.forget(proc.ev_listener)proc.ev_listener=nil end if proc.daemon then process.daemons[proc.daemon]=nil end for _,res in pairs(proc.fds)do process.closeResource(res)end proc.fds={}if process.current==proc then coroutine.yield()return end end function process.close(proc)if proc.state=="dying"then return end if not process.allProcs[proc.pid]then return end process.terminate(proc,1)proc.state="dying"local allChildren={}for _,child in pairs(proc.children)do table.insert(allChildren,child)end for _,child in ipairs(allChildren)do process.close(child)end if proc.parent then proc.parent.children[proc.pid]=nil end process.allProcs[proc.pid]=nil proc.state="dead"end function process.resolve(proc,path)if path:sub(1,1)=="/"then return Kocos.fs.join(proc.root,Kocos.fs.canonical(path))end return Kocos.fs.join(proc.root,proc.cwd,path)end function process.libreadmod(lib,module,refs)refs=refs or{}if refs[lib]then return end refs[lib]=true local mod=lib.modules[module]if mod then return mod end for _,dep in ipairs(lib.deps)do mod=process.libreadmod(dep,module,refs)if mod then return mod end end end function process.readmod(proc,module)local mod=proc.modules[module]if mod then return mod end local refs={}for _,dep in ipairs(proc.deps)do mod=process.libreadmod(dep,module,refs)if mod then return mod end end end function process.exec(proc,path,argv,env,namespace)local data=assert(readfile(path))for _,driver in ipairs(Kocos.drivers)do local img,err2=driver("PROC-binfmt",path,data,namespace)if err2 then return nil,err2 end if img then proc.exe=path proc.args=argv proc.env=env proc.namespace=namespace if proc.driver then Kocos.removeDriver(proc.driver)proc.driver=nil end proc.thread=coroutine.create(img.init)proc.modules=img.modules proc.deps={}proc.signals={}local toClose={}for fd,res in pairs(proc.fds)do if(res.opts&Kocos.fs.O_CLOEXEC)~=0 then table.insert(toClose,fd)end end for _,fd in ipairs(toClose)do local res=proc.fds[fd]process.closeResource(res)proc.fds[fd]=nil end return true end end return nil,Kocos.errno.ENOEXEC end function process.basicThread()require("_start",true)end function process.isDead(pid)return not process.allProcs[pid]end function process.isRunning(proc)return proc.state=="running"end function process.isBlocked(proc)while#proc.blockUntil>0 do if proc.blockUntil[1]()then table.remove(proc.blockUntil,1)else return true end end return false end function process.blockUntil(proc,condition)table.insert(proc.blockUntil,condition)if proc.thread==coroutine.running()then coroutine.yield()elseif process.current.pid==proc.pid then while process.isBlocked(proc)do coroutine.yield()end end end function process.resume(proc)if proc.stopped then return end if process.isBlocked(proc)then return end if not process.isRunning(proc)then return end if coroutine.status(proc.thread)~="suspended"then return end local old=process.current process.current=proc.reEnterAs or proc proc.executionDeadline=computer.uptime()+0.2 local ok,err=coroutine.resume(proc.thread)proc.reEnterAs=process.current if proc.reEnterAs==proc then proc.reEnterAs=nil end process.current=old if not ok then Kocos.printkf(Kocos.L_ERROR,"Process %d crashed: %s",proc.pid,debug.traceback(proc.thread,err))process.raise(proc,process.SIGTRAP,debug.traceback(proc.thread,err))return end if not process.isRunning(proc)then return end if coroutine.status(proc.thread)=="dead"then local exit=err if type(exit)~="number"then exit=0 end process.terminate(proc,exit)end end function process.isRoot(proc)return proc.uid==0 or proc.euid==0 end function process.run()for _,proc in pairs(process.allProcs)do process.resume(proc)end end local rawload=load function load(chunk,chunkname,mode,env)return rawload(chunk,chunkname,mode,env or process.current.namespace)end Kocos.printk(Kocos.L_DEBUG,"process system loaded")Kocos.printk(Kocos.L_DEBUG,"creating kernel process")process.current=process.create(coroutine.running(),_G,0,0)process.root=process.current Kocos.process=process local process=Kocos.process function require(modname,uncached,env)env=env or process.current.namespace if env.package.loaded[modname]~=nil and not uncached then return env.package.loaded[modname],':loaded:'end local mod=process.readmod(process.current,modname)if mod then local f=assert(load(mod.data,"="..mod.src))local v=f(modname,uncached)if v==nil then v=true end if not uncached then env.package.loaded[modname]=v end return v,':module:'end local luaCode=package.searchpath(modname,process.current.env["LUA_PATH"]or env.package.path)if luaCode then local v=dofile(luaCode,modname,uncached)if v==nil then v=true end if not uncached then env.package.loaded[modname]=v end return v,luaCode end error("could not find module: "..modname,2)end function Kocos._default_luaExec(ev,path,data,namespace)if ev~="PROC-binfmt"then return end if data:sub(1,6)~="--!lua"then return end local init,err=load(data,"="..path,nil,namespace)if not init then return nil,err end return{init=function()require(Kocos.args.luaExecRT or"luart")local ok,exitcode=xpcall(init,debug.traceback,table.unpack(Kocos.process.current.args))if ok then if type(exitcode)=="number"then Kocos.process.terminate(Kocos.process.current,exitcode)else Kocos.process.terminate(Kocos.process.current,0)end else Kocos.process.raise(Kocos.process.current,"SIGTRAP",exitcode)end end,deps={Kocos.args.luaExecRTF},modules={},}end function Kocos._default_shebang(ev,path,data,namespace)if ev~="PROC-binfmt"then return end if data:sub(1,2)~="#!"then return end local nl=string.find(data,"\n")if nl then data=string.sub(data,1,nl-1)end local cmd=data:sub(3)local args=string.split(cmd," ")cmd=table.remove(args,1)table.insert(args,path)return{init=function()local ok,err=syscall("exec",cmd,args)if ok then Kocos.process.terminate(Kocos.process.current,0)else Kocos.process.raise(Kocos.process.current,"SIGTRAP",err)end end,deps={},modules={},}end Kocos.addDriver(Kocos._default_luaExec)Kocos.addDriver(Kocos._default_shebang)local net={}local errno=Kocos.errno net.O_NONBLOCK=Kocos.fs.O_NONBLOCK net.EV_CLOSED=Kocos.fs.EV_CLOSED net.EV_DATAREADY=Kocos.fs.EV_DATAREADY net.EV_WRITEDONE=Kocos.fs.EV_WRITEDONE net.EV_CONNECTDONE="connect-done"function net.getaddrinfo(domain,protocol,host,service)for _,driver in ipairs(Kocos.drivers)do local s,err=driver("NET-addrinfo",domain,protocol,host,service)if err then return nil,err end if s then return s end end return nil,errno.ENODRIVER end function net.socket(domain,socktype,protocol)for _,driver in ipairs(Kocos.drivers)do local s,err=driver("NET-socket",domain,socktype,protocol)if err then return nil,err end if s then return s end end return nil,errno.ENODRIVER end function net.write(socket,data)if socket.state~="connected"then return false,errno.EAGAIN end if socket.write then return socket:write(data)end return false,errno.EBADF end function net.read(socket,len)if socket.state~="connected"then return nil,errno.EAGAIN end if socket.read then return socket:read(len)end return nil,errno.EBADF end function net.notify(socket,ev,...)if socket.listener then socket:listener(ev,...)end end function net.close(socket)net.notify(socket,net.EV_CLOSED)socket.state="closed"if socket.close then return socket:close()end end function net.ioctl(socket,action,...)if socket.ioctl then return socket:ioctl(action,...)end return nil,errno.EBADF end function net.accept(socket)if socket.state~="listening"then return nil,errno.EBADF end if socket.accept then return socket:accept()end return nil,errno.EBADF end function net.connect(socket,addrinfo)if socket.state~="init"then return nil,errno.EISCONN end if socket.connect then return socket:connect(addrinfo)end return nil,errno.EBADF end function net.listen(socket,addrinfo)if socket.state=="init"then return false,errno.EISCONN end if socket.listen then return socket:listen(addrinfo)end return false,errno.EBADF end Kocos.net=net Kocos.printk(Kocos.L_DEBUG,"network subsystem loaded")local process=Kocos.process local errno=Kocos.errno local syscalls={}function syscalls.open(path,mode)if type(path)~="string"or type(mode)~="string"then return nil,errno.EINVAL end if mode~="r"and mode~="w"and mode~="a"then return nil,errno.EINVAL end path=process.resolve(process.current,path)local file,err=Kocos.fs.open(path,mode)if not file then return nil,err end local res={refc=1,opts=0,file=file}return process.moveResource(process.current,res)end function syscalls.touch(path,perms)if type(path)~="string"then return nil,errno.EINVAL end if type(perms)~="number"then return nil,errno.EINVAL end perms=math.floor(perms)path=process.resolve(process.current,path)return Kocos.fs.touch(path,perms,process.current.uid,process.current.gid)end function syscalls.mkdir(path,perms)if type(path)~="string"then return nil,errno.EINVAL end if type(perms)~="number"then return nil,errno.EINVAL end perms=math.floor(perms)path=process.resolve(process.current,path)return Kocos.fs.mkdir(path,perms,process.current.uid,process.current.gid)end function syscalls.remove(path)if type(path)~="string"then return nil,errno.EINVAL end path=process.resolve(process.current,path)return Kocos.fs.remove(path)end function syscalls.mountDev(path,addr)if type(path)~="string"then return nil,errno.EINVAL end if type(addr)~="string"then return nil,errno.EINVAL end path=process.resolve(process.current,path)if Kocos.fs.ftype(path)~=Kocos.fs.FTYPE_DIR then return nil,errno.ENOTDIR end local parentmnt,p=Kocos.fs.resolve(path,true)local dev=component.proxy(addr)if not dev then return nil,errno.ENODEV end local mnt=Kocos.fs.mount(dev)if not mnt then return nil,errno.ENODRIVER end parentmnt.submounts[p]=mnt return true end function syscalls.unmount(path)if type(path)~="string"then return false,errno.EINVAL end path=process.resolve(process.current,path)local parentmnt,p=Kocos.fs.resolve(path,true)local mnt=parentmnt.submounts[p]if not mnt then return false,errno.EISDIR end Kocos.fs.unmount(mnt)parentmnt.submounts[p]=nil return true end function syscalls.getMounts()local t={}local queue={"/"}while true do local p=table.remove(queue,1)if not p then break end local dev=Kocos.fs.resolve(p)if not t[dev.dev.address]then t[dev.dev.address]=p for mp in pairs(dev.submounts)do table.insert(queue,Kocos.fs.join(p,mp))end end end return t end function syscalls.read(fd,length)if type(fd)~="number"then return nil,errno.EINVAL end if type(length)~="number"then return nil,errno.EINVAL end local proc=process.current local f=proc.fds[fd]if f then if f.file then if f.file.read then return f.file:read(length)end return nil,errno.EBADF end if f.socket then return Kocos.net.read(f.socket,length)end end return nil,errno.EBADF end function syscalls.write(fd,data)if type(fd)~="number"then return nil,errno.EINVAL end if type(data)~="string"then return nil,errno.EINVAL end local proc=process.current local f=proc.fds[fd]if f then if f.file then return Kocos.fs.write(f.file,data)end if f.socket then return Kocos.net.write(f.socket,data)end end return nil,errno.EBADF end function syscalls.close(fd)if type(fd)~="number"then return nil,errno.EINVAL end local proc=process.current local f=proc.fds[fd]if not f then return nil,errno.EBADF end proc.fds[fd]=nil process.closeResource(f)return true end function syscalls.seek(fd,whence,off)if type(fd)~="number"then return nil,errno.EINVAL end local proc=process.current local f=proc.fds[fd]if not f then return nil,errno.EBADF end if f.file then return Kocos.fs.seek(f.file,whence,off)end return nil,errno.EBADF end function syscalls.ioctl(fd,action,...)if type(fd)~="number"then return nil,errno.EINVAL end local proc=process.current local f=proc.fds[fd]if not f then return nil,errno.EBADF end if f.file then return Kocos.fs.ioctl(f.file,action,...)end if f.socket then return Kocos.net.ioctl(f.socket,action,...)end return nil,errno.EBADF end function syscalls.getaddrinfo(domain,protocol,host,service)if type(domain)~="string"then return nil,errno.EINVAL end if type(protocol)~="string"then return nil,errno.EINVAL end if type(host)~="string"then return nil,errno.EINVAL end if type(service)~="string"and type(service)~="number"and type(service)~="nil"then return nil,errno.EINVAL end return Kocos.net.getaddrinfo(domain,protocol,host,service)end function syscalls.socket(domain,socktype,protocol)if type(domain)~="string"then return nil,errno.EINVAL end if type(socktype)~="string"then return nil,errno.EINVAL end if type(protocol)~="string"and type(protocol)~="nil"then return nil,errno.EINVAL end local sock,err=Kocos.net.socket(domain,socktype,protocol)if not sock then return nil,err end return Kocos.process.moveResource(Kocos.process.current,{refc=1,opts=0,socket=sock,})end function syscalls.accept(fd)local res=process.current.fds[fd]if not res then return nil,errno.EBADF end local s=res.socket if not s then return nil,errno.ENOTSOCK end local client,err=Kocos.net.accept(s)if not client then return nil,err end return Kocos.process.moveResource(Kocos.process.current,{refc=1,opts=0,socket=client,})end function syscalls.connect(fd,addrinfo)setmetatable(addrinfo,nil)local res=process.current.fds[fd]if not res then return nil,errno.EBADF end local s=res.socket if not s then return nil,errno.ENOTSOCK end return Kocos.net.connect(s,addrinfo)end function syscalls.listen(fd,addrinfo)setmetatable(addrinfo,nil)local res=process.current.fds[fd]if not res then return nil,errno.EBADF end local s=res.socket if not s then return nil,errno.ENOTSOCK end return Kocos.net.listen(s,addrinfo)end function syscalls.dup(fd)local res=process.current.fds[fd]if not res then return nil,errno.EBADF end local f=process.moveResource(process.current,res)res.refc=res.refc+1 return f end function syscalls.dup2(fd,newFd)local res=process.current.fds[fd]if not res then return false,errno.EBADF end if process.current.fds[newFd]then return false,errno.EEXIST end process.current.fds[newFd]=res res.refc=res.refc+1 return true end function syscalls.fcntl(fd,action,...)if type(fd)~="number"then return nil,errno.EINVAL end local proc=process.current local f=proc.fds[fd]if not f then return nil,errno.EBADF end if action==Kocos.fs.F_SETCB then local listener=...if type(listener)~="function"and type(listener)~="nil"then return nil,errno.EINVAL end if f.file then return Kocos.fs.setlistener(f.file,listener)end return nil,errno.EBADF end if action==Kocos.fs.F_GETFL then return f.opts end if action==Kocos.fs.F_SETFL then local flags=...if type(flags)~="number"then return nil,errno.EINVAL end flags=math.abs(math.floor(flags))f.opts=flags if f.file then f.file.flags=flags end if f.socket then f.socket.flags=flags end return true end if action==Kocos.fs.F_NOTIF then local ev=...if type(ev)~="string"then return nil,errno.EINVAL end if f.file then Kocos.fs.notify(f.file,...)return true end if f.socket then Kocos.net.notify(f.socket,...)return true end return nil,errno.EBADF end return nil,errno.EINVAL end function syscalls.list(path)path=process.resolve(process.current,path)return Kocos.fs.list(path)end function syscalls.stat(path)path=process.resolve(process.current,path)return Kocos.fs.stat(path)end function syscalls.ftype(path)path=process.resolve(process.current,path)return Kocos.fs.ftype(path)end function syscalls.exists(path)path=process.resolve(process.current,path)return Kocos.fs.exists(path,true)end function syscalls.absolutepath(path)return Kocos.fs.fromRoot(process.resolve(process.current,path),process.current.root)end function syscalls.canonical(path)return Kocos.fs.canonical(path)end function syscalls.parentPath(path)return Kocos.fs.parentPath(path)end function syscalls.join(s,...)return Kocos.fs.join(process.resolve(process.current,s),...)end function syscalls.validlink(path)path=process.resolve(process.current,path)return Kocos.fs.exists(path)end function syscalls.fork(f)local child=process.fork(process.current,f)process.resume(child)return child.pid end function syscalls.environ()return process.current.env end function syscalls.argv()return process.current.args end function syscalls.sleep(time)if type(time)~="number"then return nil,errno.EINVAL end local deadline=computer.uptime()+time process.blockUntil(process.current,function()return computer.uptime()>=deadline end)return true end function syscalls.uptime()return computer.uptime()end function syscalls.sync()Kocos.fs.sync()return true end function syscalls.exec(path,argv,env,namespace)if type(path)~="string"then return false,errno.EINVAL end local cur=process.current argv=argv or{[0]=path}argv[0]=argv[0]or path env=env or table.copy(cur.env)namespace=namespace or cur.namespace local ok,err=process.exec(cur,path,argv,env,namespace)if not ok then return false,err end coroutine.yield()return true end function syscalls.readmod(module)if type(module)~="string"then return nil,errno.EINVAL end local mod=process.readmod(process.current,module)if mod then return mod.data,mod.src end return nil,errno.ENOENT end function syscalls.clist(filter,exact)local t={}for addr,type in component.list(filter,exact)do t[addr]=type end local k setmetatable(t,{__call=function()k=next(t,k)return k,t[k]end,})return t end function syscalls.caddress(shortform,filter,exact)if type(shortform)~="string"then return nil,errno.EINVAL end local l,err=syscalls.clist(filter,exact)if err then return nil,err end for addr in l do if string.startswith(addr,shortform)then return addr end end return nil,errno.ENODEV end function syscalls.cadd(dev)if not process.isRoot(process.current)then return false,errno.EPERM end if component.type(dev.address)then return false,errno.EADDRINUSE end component.add(dev)return true end function syscalls.cremove(address)if not process.isRoot(process.current)then return false,errno.EPERM end if not component.isVirtual(address)then return false,errno.ENODEV end component.remove(address)return true end function syscalls.cramfs(image,label,readonly,addr)if not process.isRoot(process.current)then return nil,errno.EPERM end return Kocos.addRamfsComponent({label=label,readonly=readonly,fds={},image=image,},addr)end function syscalls.cmethods(addr)return component.methods(addr)end function syscalls.cinvoke(addr,method,...)return component.invoke(addr,method,...)end function syscalls.cproxy(addr)return component.proxy(addr)end function syscalls.cprimary(type)return component.getPrimary(type)end function syscalls.cfields(addr)return component.fields(addr)end function syscalls.cdoc(addr,method)return component.doc(addr,method)end function syscalls.cslot(addr)return component.slot(addr)end function syscalls.ctype(addr)return component.type(addr)end function syscalls.waitpid(pid)local proc=process.allProcs[pid]if not proc then return 0 end process.resume(proc)process.blockUntil(process.current,function()return not process.isRunning(proc)end)process.close(proc)return proc.exitcode end function syscalls.blockUntil(pid,condition)local p=process.allProcs[pid]if not p then return false,errno.ESRCH end if type(condition)~="function"then return false,errno.EINVAL end if condition()then return true end local cur=process.current if cur.uid~=0 and not process.isDecendantOf(p,cur)then return nil,errno.EPERM end process.blockUntil(p,function()local ok,s=process.pcall(cur,condition)if not ok then return false end return s end)return true end function syscalls.chdir(dir)if type(dir)~="string"then return nil,errno.EINVAL end if dir=="."then return process.current.cwd end dir=process.resolve(process.current,dir)dir=Kocos.fs.fromRoot(dir,process.current.root)process.current.cwd=dir return dir end function syscalls.chroot(dir)if type(dir)~="string"then return nil,errno.EINVAL end if dir=="."then return process.current.cwd end dir=process.resolve(process.current,dir)process.current.root=dir return dir end function syscalls.sysinfo()return{kernel=_KVERSION,os=_OSVERSION,bootAddress=computer.getBootAddress(),rootAddress=Kocos.fs.root.dev.address,tmpAddress=computer.tmpAddress(),memfree=computer.freeMemory(),memtotal=computer.totalMemory(),hostname=Kocos.hostname,kernelPID=process.root.pid,initPID=process.init.pid,energy=computer.energy(),maxEnergy=computer.maxEnergy(),}end function syscalls.chboot(addr)if addr then if type(addr)~="string"then return nil,errno.EINVAL end if process.current.euid~=0 then return nil,errno.EPERM end computer.setBootAddress(addr)end return computer.getBootAddress()end function syscalls.chsysroot(addr)if type(addr)~="string"then return false,errno.EINVAL end if process.current.euid~=0 then return false,errno.EPERM end local proxy=component.proxy(addr)if not proxy then return false,errno.ENODEV end local newRoot=Kocos.fs.mount(proxy)if not newRoot then return false,errno.ENODRIVER end local oldRoot=Kocos.fs.root Kocos.fs.root=newRoot if oldRoot then Kocos.fs.unmount(oldRoot)end return true end function syscalls.hostname(hostname)if hostname then if process.current.euid~=0 then return nil,errno.EACCESS end Kocos.hostname=hostname end return Kocos.hostname end function syscalls.syscalls()local s={}for k in pairs(syscalls)do table.insert(s,k)end return s end function syscalls.registerDaemon(daemon,callback)local d=process.daemons[daemon]if d then return nil,errno.EADDRINUSE end if process.current.daemon then return nil,errno.EALREADY end process.daemons[daemon]={proc=process.current,callback=callback,}process.current.daemon=daemon return true end function syscalls.getDaemonPid(daemon)local d=process.daemons[daemon]if not d then return nil,errno.ESRCH end return d.proc.pid end function syscalls.listDaemons()local daemons={}for addr in pairs(process.daemons)do table.insert(daemons,addr)end return daemons end function syscalls.invokeDaemon(daemon,...)local d=process.daemons[daemon]if not d then return nil,errno.ESRCH end local t={process.pcall(d.proc,d.callback,process.current.pid,...)}if t[1]then return table.unpack(t,2)end return nil,table.unpack(t,2)end function syscalls.getprocs()local pids={}for pid in pairs(process.allProcs)do table.insert(pids,pid)end return pids end function syscalls.isproot(pid)local p=process.allProcs[pid]if not p then return false end return process.isRoot(p)end function syscalls.getpid()return process.current.pid end function syscalls.getuid()return process.current.uid end function syscalls.getgid()return process.current.gid end function syscalls.geteuid()return process.current.euid end function syscalls.getegid()return process.current.egid end function syscalls.setuid(uid,pid)local cur=process.current local target=process.allProcs[pid or cur.pid]if not target then return false,errno.ESRCH end if not process.isDecendantOf(target,cur)then return false,errno.EPERM end if uid==0 and not process.isRoot(cur)then return false,errno.EPERM end target.uid=uid return true end function syscalls.strace(pid)local p=process.allProcs[pid]if not p then return false,errno.ESRCH end if not process.isDecendantOf(process.current,p)then return false,errno.EPERM end process.current.tracer=p return true end function syscalls.setgid(gid,pid)local cur=process.current local target=process.allProcs[pid or cur.pid]if not target then return false,errno.ESRCH end if not process.isDecendantOf(target,cur)then return false,errno.EPERM end if gid==0 and not process.isRoot(cur)then return false,errno.EPERM end target.gid=gid return true end function syscalls.seteuid(uid,pid)local cur=process.current local target=process.allProcs[pid or cur.pid]if not target then return false,errno.ESRCH end if not process.isDecendantOf(target,cur)and not process.isRoot(cur)then return false,errno.EPERM end if uid==0 and not process.isRoot(cur)then target.euid=target.uid return true end target.euid=uid return true end function syscalls.setegid(gid,pid)local cur=process.current local target=process.allProcs[pid or cur.pid]if not target then return false,errno.ESRCH end if not process.isDecendantOf(target,cur)and not process.isRoot(cur)then return false,errno.EPERM end if gid==0 and not process.isRoot(cur)then target.egid=target.gid return true end target.egid=gid return true end function syscalls.getprocinfo(pid,...)local proc=process.allProcs[pid]if not proc then return nil,errno.ESRCH end local isTrusted=process.current.euid==0 or process.isDecendantOf(proc,process.current)local info={}local vlen=select("#",...)for i=1,vlen do local v=select(i,...)if v=="args"then info.argv=table.copy(proc.args)elseif v=="env"then info.environ=table.copy(proc.env)elseif v=="uid"then info.uid=proc.uid info.euid=proc.euid elseif v=="gid"then info.gid=proc.gid info.egid=proc.egid elseif v=="parent"then if proc.parent then info.parent=proc.parent.pid end elseif v=="tree"then if proc.parent then info.parent=proc.parent.pid end info.children={}for cpid in pairs(proc.children)do table.insert(info.children,cpid)end elseif v=="state"then if proc.parent then info.parent=proc.parent.pid end if proc.tracer then info.tracer=proc.tracer.pid end info.driver=not not proc.driver info.exitcode=proc.exitcode info.exe=proc.exe info.cwd=proc.cwd elseif v=="namespace"then if isTrusted then info.namespace=proc.namespace end elseif v=="signals"then info.signals={}for sig in pairs(proc.signals)do table.insert(info.signals,sig)end end end return info end function syscalls.proclocal()return process.current.proclocal end function syscalls.kill(pid,signal,...)local cur=process.current local target=process.allProcs[pid]if not target then return nil,errno.ESRCH end if signal=="SIGTRAP"then return nil,errno.EPERM end if signal=="SIGCHLD"then return nil,errno.EPERM end if signal=="SIGABRT"then return nil,errno.EPERM end local allowed=process.isRoot(cur)or cur.uid==target.uid or cur.euid==target.euid or cur.euid==target.uid if not allowed then return nil,errno.EPERM end process.raise(target,signal,...)return true end function syscalls.signal(sig,f)process.current.signals[sig]=f return true end function syscalls.abort()process.raise(process.current,process.SIGABRT)end function syscalls.exit(code)code=code or 0 process.terminate(process.current,code)return 0 end function syscalls.mkdriver(driver)local cur=process.current if cur.euid~=0 then return nil,errno.EPERM end if cur.driver then Kocos.removeDriver(driver)end cur.driver=driver Kocos.addDriver(driver)return true end function syscalls.mklistener(listener)local cur=process.current if cur.euid~=0 then return nil,errno.EPERM end if cur.ev_listener then Kocos.event.forget(cur.ev_listener)end cur.ev_listener=listener Kocos.event.listen(listener)return true end function syscalls.errnos()return table.copy(Kocos.errno)end function syscalls.resume(pid)local proc=process.allProcs[pid]if not proc then return false,errno.ESRCH end process.resume(proc)return true end Kocos.syscalls=syscalls function syscall(sysname,...)local cur=process.current if cur.executionDeadline and computer.uptime()>cur.executionDeadline then coroutine.yield()end if process.isDead(cur.pid)then return nil,errno.ECHILD end if not syscalls[sysname]then return nil,errno.ENOSYS end if cur.tracer then process.raise(cur.tracer,process.SIGSYSC,cur.pid,sysname,{...})end local t={pcall(syscalls[sysname],...)}if cur.tracer then local ret=t[1]and{table.unpack(t,2)}or{nil,t[2]}process.raise(cur.tracer,process.SIGSYSR,cur.pid,sysname,{...},ret)end if not process.isRunning(process.current)then coroutine.yield()end if t[1]then return table.unpack(t,2)end return nil,t[2]end Kocos.printkf(Kocos.L_INFO,"Booting %s...",_KVERSION)Kocos.printkf(Kocos.L_DEBUG,"Detecting hardware...")for addr,type in component.list()do Kocos.printkf(Kocos.L_DEBUG,"%s %s",addr,type)end Kocos.printk(Kocos.L_INFO,"mounting boot filesystem at /")local rootDev if Kocos.args.ramfs then rootDev=Kocos.addRamfsComponent(Kocos.args.ramfs,"ramfs")Kocos.printk(Kocos.L_DEBUG,"mounting as ramfs tmp root")else rootDev=Kocos.args.root or computer.getBootAddress()Kocos.printk(Kocos.L_DEBUG,"mounting as managedfs true root")end do assert(rootDev,"missing root device")assert(Kocos.syscalls.chsysroot(rootDev))end local freeMem=computer.freeMemory()local totalMem=computer.totalMemory()Kocos.printkf(Kocos.L_INFO,"Free Memory: %s / %s",string.memformat(freeMem),string.memformat(totalMem))Kocos.shutdown=nil if freeMem<64*1024 then Kocos.printkf(Kocos.L_WARN,"FREE MEMORY IS BELOW 64KiB!!!")end local function tick()if Kocos.shutdown then Kocos.printkf(Kocos.L_INFO,"Attempting %s",Kocos.shutdown)Kocos.poweroff(Kocos.shutdown=="reboot")return end Kocos.process.run()local interval=Kocos.args.pollInterval or 0 local percent=computer.energy()/computer.maxEnergy()if percent<0.5 then interval=Kocos.args.midBatteryPollInterval or 0.1 end if percent<0.1 then interval=Kocos.args.midBatteryPollInterval or 0.2 end Kocos.event.pull(interval)end local initPaths={"/sbin/init","/bin/init","/sbin/login","/bin/login","/sbin/sh","/bin/sh",}local initProc=Kocos.process.fork(Kocos.process.root,function()Kocos.process.init.executionDeadline=math.huge for _,path in ipairs(initPaths)do if Kocos.syscalls.exists(path)then Kocos.printkf(Kocos.L_INFO,"Running %s...",path)assert(Kocos.syscalls.exec(path))end end Kocos.panickf("COULD NOT FIND INIT PROGRAM!\nSearched: %s\n",table.concat(initPaths,"\n"))end)Kocos.process.init=initProc initProc.fds[1]={refc=4,opts=0,file=Kocos.fs.fd_from_rwf(function(_,len)return Kocos.scr_read(len)end,function(_,data)local bufSize=1024 if#data<=bufSize then Kocos.scr_write(data)return true end for i=1,#data,bufSize do local buf=data:sub(i,i+bufSize-1)Kocos.scr_write(buf)coroutine.yield()end return true end,nil,function(_,...)return Kocos.scr_ioctl(...)end),}initProc.fds[0]=initProc.fds[1]initProc.fds[2]=initProc.fds[1]initProc.fds[3]=initProc.fds[1]Kocos.process.resume(initProc)local function justDie()pcall(computer.pullSignal,2)computer.shutdown(true)end while true do local ok,err=xpcall(tick,debug.traceback)if not ok then pcall(Kocos.panickf,"Tick error: %s\n",err)justDie()end end